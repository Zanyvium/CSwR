# Numerical optimization {#numopt}

The main application of numerical optimization in statistics is for the 
computation of parameter estimates. Typically by maximizing the likelihood 
function or by maximizing or minimizing another estimation criterion. The focus of this
chapter is on optimization algorithms for (penalized) maximum likelihood 
estimation, in particular for exponential families. Out of tradition we 
formulate all results and algorithms in terms of minimization and 
not maximization. 

The generic optimization problem considered is the minimization of 
$H : \Theta \to \mathbb{R}$ for $\Theta \subseteq \mathbb{R}^p$ an 
open set and $H$ twice differentiable. In applications, $H = -\ell$, 
the negative log-likelihood function, or $H = -\ell + J$, where $J : \Theta \to \mathbb{R}$
is a *penalty function*, likewise twice differentiable, that does not
depend upon data. 

There are a couple of observations regarding statistical optimization
problems that are worthwhile to make once and for all. The $-\ell$ 
term in the objective function to be minimized is a sum over the 
data, and the more data we have the more computationally demanding 
it is to evaluate $H$ and its derivatives. There are exceptions, though, 
when a sufficient statistic can be computed upfront. Additionally, high precision in
the computed (local) minimizer is rarely needed. If the numerical 
error is already orders of magnitudes smaller than the statistical 
uncertainty of the parameter estimate being computed, further 
optimization will not make a difference in any relevant way. 

In fact, blindly pursuing the global maximum of the likelihood can very well 
lead you astray if your model is not as well 
behaved as an exponential family is. In situations where $H$ is 
not convex, as is the case for finite mixtures, there are common examples where 
the likelihood is unbounded, yet there will be a local minimizer that is a 
good estimate. Though we typically phrase our algorithms 
as optimization algorithms, what we are really pursuing
when $H$ is not convex are stationary points; solutions to $\nabla H(\theta) = 0$. 
And rather than being fixated on computing the global minimizer of $H$ 
to the greatest numerical precision, we should find as many 
approximately stationary points as possible, and more generally explore 
the likelihood surface. In this respect, optimization 
in statistics differs from certain other applications of optimization. Finding
the optimum is not "the thing". It is a surrogate for "the thing", which is
to fit models to data *and* understand the statistical precision of our fitted
model. That is, as a minimum we should quantify the uncertainty of 
(relevant aspects of) the fitted model that is due to the finite sample size.

For the generic minimization problem considered in this chapter, the practical 
challenge when implementing algorithms in R is typically 
to implement efficient evaluation of $H$ and its derivatives. In particular, 
efficient evaluations of $-\ell$. Several choices of standard optimization
algorithms are possible and some are already implemented and available in R. 
For many practical purposes the BFGS-algorithms as implemented via the `optim` 
function work well and require only the computation of gradients. It is, of course,
paramount that $H$ and $\nabla H$ are correctly implemented, and 
efficiency of the algorithms is largely determined by the efficiency of
the implementation of $H$ and $\nabla H$ but also by the choice of parametrization. 
Newton-type algorithms are available through `nlm` and `nls` but with different
interfaces. 

## Algorithms and convergence

A numerical optimization algorithm computes from an initial value 
$\theta_0 \in \Theta$ a sequence $\theta_1, \theta_2, \ldots \in \Theta$.
One could hope for 
$$\theta_n \rightarrow \text{arg min}_{\theta} H(\theta)$$
for $n \to \infty$, but much less can typically be guaranteed. First, 
the global minimizer may not exist or it may not be unique, in which 
case the convergence itself is undefined or ambiguous. Second, $\theta_n$
can in general only be shown to converge to a *local* minimizer if anything. 
Third, $\theta_n$ may not even converge, but $H(\theta_n)$
may still converge to a local minimum. 

This section will give a brief introduction to convergence analysis 
of optimization algorithms. We will see what kind of conditions on $H$ can be 
used to show  convergence results and some of the basic proof techniques.
We will only scratch the surface here with the intention that it can motivate
the algorithms introduced in subsequent sections and chapters as well 
as the empirical techniques introduced below for practical assessment of 
convergence.

Indeed, theory rarely provides us with sharp quantitative results on 
the rate of convergence and we will need computational techniques to monitor and measure convergence of algorithms in practice. Otherwise we cannot compare 
the efficiency of different algorithms. 

### Descent algorithms

```{example, grad-descent}
Suppose that $D^2H(\theta)$ has *numerical radius* uniformly bounded by $L$, that is,
$$|\gamma^T D^2H(\theta) \gamma| \leq L \|\gamma\|_2^2$$
for all $\theta \in \Theta$ and $\gamma \in \mathbb{R}^p$. Define 
an algorithm by 
$$\theta_{n} = \theta_{n-1} - \frac{1}{L + 1} \nabla H(\theta_{n-1}).$$
Fixing $n$ there is by Taylor's theorem a
$\tilde{\theta} = \alpha \theta_{n} + (1- \alpha)\theta_{n-1}$ (where $\alpha \in [0,1]$) 
on the line between $\theta_n$ and $\theta_{n-1}$ such that

\begin{align*}
H(\theta_n) & = H(\theta_{n-1}) - \frac{1}{L+1} \|\nabla H(\theta_{n-1})\|_2^2 +  
  \frac{1}{(L+1)^2} \nabla H(\theta_{n-1})^T D^2H(\tilde{\theta}) \nabla H(\theta_{n-1}) \\
& \leq H(\theta_{n-1}) - \frac{1}{L+1} \|\nabla H(\theta_{n-1})\|_2^2 + 
   \frac{L}{(L+1)^2} \|\nabla H(\theta_{n-1})\|_2^2 \\
& = H(\theta_{n-1}) - \frac{1}{(L+1)^2} \|\nabla H(\theta_{n-1})\|_2^2.
\end{align*}
  
This shows that $H(\theta_n) \leq H(\theta_{n-1})$, and if $\theta_{n-1}$ is not a 
stationary point, $H(\theta_n) < H(\theta_{n-1})$. That is, the algorithm 
will produce a sequence with non-increasing $H$-values, and unless it 
hits a stationary point the $H$-values will be strictly decreasing. The 
algorithm is an example of a *gradient descent* algorithm.

```

In general, we define a *descent algorithm* to be an algorithm for which
$$H(\theta_0) \geq H(\theta_1) \geq H(\theta_2) \geq \ldots.$$
If all inequalities are sharp, unless if some $\theta_i$ is a local minimizer, 
the algorithm is called a *strict* descent algorithm. The gradient descent
algorithm in Example \@ref(exm:grad-descent) is a strict descent algorithm.
However, even for a strict descent algorithm, $H$ may just descent in smaller 
and smaller steps without converging toward a local minimum -- even if $H$ is 
bounded below. 

Suppose now that $H$ is *level bounded*, 
meaning that the closed set
$$\mathrm{lev}(\theta_0) =  \{\theta \in \Theta \mid H(\theta) \leq H(\theta_0)\}$$
is bounded (and thereby compact). Then $H$ is bounded from below and 
$H(\theta_n)$ is convergent for any descent algorithm. 
Restricting attention to the gradient descent algorithm, we see that 

\begin{align}
H(\theta_n) & = 
(H(\theta_n) - H(\theta_{n-1})) + (H(\theta_{n-1}) - H(\theta_{n-2})) + ... + 
(H(\theta_1) - H(\theta_0)) + H(\theta_0) \\
& \leq H(\theta_0) - \frac{1}{(L + 1)^2} \sum_{k=1}^n \|\nabla H(\theta_{k-1})\|_2^2.
\end{align}

Because $H$ is bounded below, this implies that $\sum_{k=1}^{\infty} \|\nabla H(\theta_{k-1})\|_2^2 < \infty$
and hence
$$\|\nabla H(\theta_{n})\|_2 \rightarrow 0$$
for $n \to \infty$. By compactness of $\mathrm{lev}(\theta_0)$,
$\theta_n$ has a convergent subsequence with limit $\theta_{\infty}$, and 
we conclude by continuity of $\nabla H$ that 
$$\nabla H(\theta_{\infty}) = 0,$$
and $\theta_{\infty}$ is a stationary point. In fact, this holds for any 
limit point of the sequence, and this implies that if $H$ has a *unique*
stationary point in $\mathrm{lev}(\theta_0)$, $\theta_{\infty}$ is a minimizer, 
and 
$$\theta_n \rightarrow \theta_{\infty}$$
for $n \to \infty$. 

To summarize, if $D^2H(\theta)$ has uniformly bounded numerical radius, and if
$H$ is level bounded with a unique stationary point in $\mathrm{lev}(\theta_0)$, 
then the gradient descent algorithm of Example \@ref(exm:grad-descent) is a strict descent
algorithm that converges toward that minimum. A sufficient condition 
on $H$ for this to hold is that the eigenvalues of (the symmetric) matrix 
$D^2H(\theta)$ for all $\theta$ are contained in an interval $[l, L]$ 
with $0 < l \leq L$. In this case, $H$ is a *strongly convex function* 
with a unique global minimizer. 

### Maps and fixed points

Most algorithms take the form of an *update scheme*, which from a mathematical
viewpoint is a map $\Phi : \Theta \to \Theta$ such that 
$$\theta_n = \Phi(\theta_{n-1}) = \Phi \circ \Phi (\theta_{n-2}) =  \Phi^{\circ n}(\theta_0).$$
The gradient descent algorithm from Example \@ref(exm:grad-descent) is given 
by the map 
$$\Phi_{\nabla}(\theta) = \theta - \frac{1}{L + 1} \nabla H(\theta).$$
When the map $\Phi$ is continuous and $\theta_n \rightarrow \theta_{\infty}$
it follows that 
$$\Phi(\theta_n) \rightarrow \Phi(\theta_{\infty}).$$
Since $\Phi(\theta_n) = \theta_{n+1} \rightarrow \theta_{\infty}$ we see that
$$\Phi(\theta_{\infty}) = \theta_{\infty}.$$
That is, $\theta_{\infty}$ is a *fixed point* of $\Phi$. The gradient descent 
map, $\Phi_{\nabla}$, has $\theta$ as fixed point if and only if  
$$\nabla H(\theta) = 0,$$
that is, if and only if $\theta$ is a stationary point. 

We can use the  observation above to flip the perspective around. Instead of asking if $\theta_n$ converges to a 
local minimizer for a given algorithm, we can ask if we can find a map
$\Phi: \Theta \to \Theta$ whose fixed points are local minimizers. If so, we 
can ask if the iterates $\Phi^{\circ n}(\theta_0)$ converge. Mathematics
is full of *fixed point theorems* that: i) give conditions under which a map 
has a fixed point; and ii) in some cases guarantee that the iterates $\Phi^{\circ n}(\theta_0)$
converge. The most prominent such fixed point theorem is [Banach's fixed point 
theorem](https://en.wikipedia.org/wiki/Banach_fixed-point_theorem). 
It states that if $\Phi$ is a *contraction*, that is,
$$\| \Phi(\theta) - \Phi(\theta')\| \leq c \|\theta - \theta'\|$$
for a constant $c \in [0,1)$ (using any norm), then $\Phi$ has a unique 
fixed point and $\Phi^{\circ n}(\theta_0)$ converges to that fixed point for 
any starting point $\theta_0 \in \Theta$. 

We will show that $\Phi_{\nabla}$ is a contraction on $\mathrm{lev}(\theta_0)$
under the assumption that the eigenvalues of $D^2H(\theta)$ for all 
$\theta \in \mathrm{lev}(\theta_0)$ are contained in an interval $[l, L]$ 
with $0 < l \leq L$. If $\theta, \theta' \in \mathrm{lev}(\theta_0)$ we find 
by Taylor's theorem that 
$$\nabla H(\theta) = \nabla H(\theta') + D^2H(\tilde{\theta})(\theta - \theta')$$
for some $\tilde{\theta}$ on the line between $\theta$ and $\theta'$. 
For the gradient descent map this gives that

\begin{align*}
\|\Phi_{\nabla}(\theta) - \Phi_{\nabla}(\theta')\|_2 & = 
\left\|\theta - \theta' - \frac{1}{L+1}\left(\nabla H(\theta) - \nabla H(\theta')\right)\right\|_2 \\
& = 
\left\|\theta - \theta' - \frac{1}{L+1}\left( D^2H(\tilde{\theta})(\theta - \theta')\right)\right\|_2 \\
& = 
\left\|\left(I - \frac{1}{L+1} D^2H(\tilde{\theta}) \right) (\theta - \theta')\right\|_2 \\
& \leq \left(1 - \frac{l}{L + 1}\right) \|\theta - \theta'\|_2,
\end{align*}

since the eigenvalues of $I - \frac{1}{L+1} D^2H(\tilde{\theta})$ are all between 
$1 - L/(L + 1)$ and $1 - l/(L+1)$. This shows that $\Phi_{\nabla}$ is a 
contraction for the $2$-norm on $\mathrm{lev}(\theta_0)$ with 
$c = 1 - l/(L + 1) < 1$. This provides an alternative proof,
via Banach's fixed point theorem, of convergence of the gradient descent algorithm 
in Example \@ref(exm:grad-descent) for a *strongly* convex $H$ with uniformly 
bounded Hessian.

The number $c$ quantifies how fast $\theta_n$ converges toward the fixed point.
The smaller $c$ is, the faster is the convergence. Details are given in the next section, 
but it is worth noticing here that $c = 1 - l/(L + 1)$ is independent of the 
dimension of $\Theta$ for given bounds $l$ and $L$. It way also be 
worth noticing that $\kappa = (L + 1) / l$ is an upper bound on the 
[conditioning number](https://en.wikipedia.org/wiki/Condition_number#Matrices)
of the matrix $D^2H(\theta)$ uniformly in $\theta \in \mathrm{lev}(\theta_0)$. 
A large conditioning number of the second derivative indicates that the graph 
of $H$ looks like a narrow ravine, which will force $\kappa^{-1}$ to be small,
thus $c$ to be close to one and the convergence to be slow. 

### Convergence rate

Banach's fixed point theorem tells us more than just convergence. 
It actually tells us that 
$$\|\theta_n - \theta_{\infty}\| = \|\Phi(\theta_{n-1}) - \theta_{\infty}\| \leq c \|\theta_{n-1} - \theta_{\infty}\| \leq c^n \|\theta_0 - \theta_{\infty}\|.$$
That is, $\|\theta_n - \theta_{\infty}\| \to 0$ with at least geometric rate $c < 1$. 

To discuss how fast numerical optimization algorithms converge in general, 
there is a refined notion of asymptotic convergence *order* as well as 
*rate*. 

```{definition, order-rate}
We say that a convergent sequence $(\theta_n)_{n \geq 1}$ in $\mathbb{R}^p$ has asymptotic convergence order $q$ with asymptotic rate $r \in (0, 1)$ if 
$$\lim_{n \to \infty} \frac{\|\theta_{n} - \theta_{\infty}\|}{\|\theta_{n-1} - \theta_{\infty}\|^q} = r.$$
````

If the order is $q = 1$ we say that the convergence is linear, if $q = 2$
we say that the convergence is quadratic and so on. If 
$$\limsup_{n \to \infty} \frac{\|\theta_{n} - \theta_{\infty}\|}{\|\theta_{n-1} - \theta_{\infty}\|} = 1$$
we say that convergence is sublinear.
Banach's fixed point theorem implies a convergence that is at least as fast as 
linear convergence with asymptotic rate $c$. 
Moreover, if $\Phi$ is just a contraction for $n \geq N_0$ for some $N_0$, 
then for $n \geq N_0$
$$\|\theta_{n + 1} - \theta_{n}\| \leq c \| \theta_{n} - \theta_{n-1}\|.$$
The convergence may be superlinear, but if it is linear, the rate is bounded by $c$.
To indicate if $\Phi$ is asymptotically a contraction, we can introduce
$$R_n = \frac{\|\theta_{n + 1} - \theta_{n}\|}{\|\theta_{n} - \theta_{n- 1}\|}$$
and monitor its behavior as $n \to \infty$. The constant
$$r = \limsup_{n \to \infty} R_n$$
is then asymptotically the smallest possible contraction constant. 
If convergence is sublinear and $R_n \to 1$ the sequence is 
called logarithmically convergent (by definition), while $r \in (0,1)$ is an 
indication of linear convergence with rate $r$, and $r = 0$ is an indication of 
superlinear convergence.

In practice, we can plot the ratio $R_n$ as the algorithm is running, and 
use $R_n$ as an estimate of the rate $r$ for large $n$. However, 
this can be a quite unstable method for estimating the rate. Alternatively, 
we can run the algorithm for a large number, $N$, say, of iterations. 
Ideally so that $\theta_N = \theta_{\infty}$ up to computer precision. 
Then if we have linear convergence with rate $r$,
$$
\| \theta_n - \theta_N \| \simeq r \| \theta_{n-1} - \theta_N \| \simeq \ldots 
\simeq r^{n - N_0} \| \theta_{N_0} - \theta_N \|
$$
for $n \geq N_0$ and $N_0$ sufficiently large. That is, 
$$\log \|\theta_{n} - \theta_{N}\| \simeq n \log(r) + d,$$
for $n \geq N_0$, and we can plot and monitor $\log \|\theta_{n} - \theta_{N}\|$.
It should decay approximately linearly as a function of $n$ with slope 
$\log(r) < 0$, which can be estimated by least squares. If the algorithm has sublinear convergence
we will see this as a slower-than-linear decay. Finally, it is also possible to 
estimate the order $q$ as well as the rate $r$ by using that 
$$\log \|\theta_{n} - \theta_{N}\| \simeq q \log \|\theta_{n-1} - \theta_{N}\| + \log(r)$$
for $n \geq N_0$. We can estimate $q$ and $\log(r)$
by fitting a linear function by least squares to these log-log transformed norms 
of errors. 

It is, of course, possible to investigate convergence 
in terms of the sequences $H(\theta_n)$ and $\nabla H(\theta_n)$ instead. Here  $\nabla H(\theta_n)$ is particularly appealing as we know that the limit should be $0$.
We use the same terminology of order and rate for these sequences. That is, 
using the gradient to quantify convergence, the order is $q$ and the 
rate is $r \in (0, 1)$ if 
$$\lim_{n \to \infty} \frac{\|\nabla H(\theta_n)\|}{\|\nabla H(\theta_{n-1})\|^q} = r.$$
If the order is linear, the rate can then be estimated from
$$\log \|\nabla H(\theta_n)\| \simeq n \log(r) + d$$
for $n \geq N_0$ by least squares. 

It is important to notice that all rates discussed above are *per iteration*,
which is natural when investigating a single algorithm. However, different 
algorithms may spend different amounts of time per iteration, and it does not 
make sense to make a comparison of per iteration rates across different 
algorithms. If one iteration takes $\delta$ time units (seconds, say) 
the *per time unit* rate is 
$$r^{1/\delta}.$$ 
If $t_n$ denotes the run time of $n$ iterations, we could 
estimate $\delta$ as $t_N / N$ for $N$ sufficiently large. 

We will throughout systematically investigate convergence 
as a function of $t_n$ instead of $n$, and we will estimate rates per time unit
directly by least squares regression on $t_n$ instead of $n$. 

### Stopping criteria

The discussion above on theoretical convergence properties and practical 
methods for measuring convergence rates has left one important 
practical question unanswered. No algorithm can run for an infinite number 
of iterations, thus all algorithms need a criterion for when
to stop. 

We say that an algorithm *has converged* by iteration $n$ if 
$$H(\theta_n) - H(\theta_{\infty}) < \varepsilon_0$$
for an error tolerance $\varepsilon_0 > 0$. Unfortunately, we cannot
compute $H(\theta_n) - H(\theta_{\infty})$, and the choice of an 
appropriate stopping criterion is notoriously difficult. 
Below we give four of the most commonly used criteria and 
discuss benefits and deficits for each of them. They can be used 
individually and in combinations, but unfortunately none of them 
provides convergence guarantees. It is nevertheless common to abuse 
the terminology and say that an algorithm has converged when a stopping 
criterion is reached, but this can be misleading. 

**Maximal number of iterations:** Stop when 
$$n = N$$ 
for a fixed maximal number of iterations $N$. 
This is arguably the simplest criterion, but, obviously, 
reaching a maximal number of iterations provides no evidence in 
itself that $H(\theta_N)$ is sufficiently close to a (local) minimum. For 
a specific problem we could from experience know of a sufficiently large
$N$ so that the algorithm has typically converged after $N$ iterations, but
the most important use of this criterion is in combination with another 
criteria so that it works as a safeguard against an infinite loop.

The other three stopping criteria all depend on choosing a *tolerance parameter* $\varepsilon > 0$, which will play different roles in the three 
criteria.

**Small relative change:** Stop when 
$$\|\theta_n - \theta_{n-1}\| \leq \varepsilon(\|\theta_n\| + \varepsilon).$$
The idea is that when $\theta_n \simeq \theta_{n-1}$ the sequence has approximately
reached the limit $\theta_{\infty}$ and we can stop. It is possible to use an
absolute criterion such as $\|\theta_n - \theta_{n-1}\| < \varepsilon$, but then 
the criterion would be sensitive to a rescaling of the parameters. Thus fixing a 
reasonable tolerance parameter across many problems makes more sense for the 
relative then the absolute criterion. The main reason for adding $\varepsilon$
on the right hand size is to make the criterion well behaved even if 
$\|\theta_n\|$ is close to zero. 

The main benefit of this criterion is that it does not require evaluations 
of the objective function. Some algorithms, such as the EM-algorithm, does not
need to evaluate the objective function, and it may even be difficult to do so. 
In those cases this criterion can be used. The main deficit is that a 
single iteration with little change in the parameter can happen for many 
reasons besides convergence, and it does not imply that
$H(\theta_{n}) - H(\theta_{\infty})$ is small.

**Small relative descent:** Stop when 
$$H(\theta_{n-1}) - H(\theta_n) \leq \varepsilon (|H(\theta_n)| + \varepsilon).$$
This criterion only makes sense if the algorithm is a descent algorithm.
As discussed above, an absolute criterion would be sensitive to rescaling of 
the objective function, and the added $\varepsilon$ 
on the right hand side is to ensure a reasonable behavior if $H(\theta_n)$
is close to zero. 

This criterion is natural for descent algorithms; we stop when the algorithm
does not decrease the value of the objective function sufficiently. 
The use of a relative criterion makes is possible to choose a tolerance 
parameter that works reasonably well for many problems. A conventional choice 
is $\varepsilon \simeq 10^{-8}$ (and often chosen as the square root of the 
[machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon)), though 
the theoretical support for this choice is weak. The deficit of the 
algorithm is as for the criterion above: a small descent does not imply that $H(\theta_{n}) - H(\theta_{\infty})$ is small, and it could happen if the 
algorithm enters a part of $\Theta$ where $H$ is very flat, say. 

**Small gradient:** Stop when 
$$\|\nabla H(\theta_n)\| \leq \varepsilon.$$
This criterion directly measures if $\theta_n$ is close to being a stationary 
point, but a small value of $\|\nabla H(\theta_n)\|$ is still no guarantee that
$H(\theta_{n}) - H(\theta_{\infty})$ is small. The criterion also requires
the computation of the gradient. 

Observe, in addition, that different norms, $\|\cdot\|$, can be used, and
if the coordinates of the gradient generally are of different orders of 
magnitude a norm that rescales the coordinates can be chosen. 

Neither of the four criteria above give a theoretical convergence guarantee, but 
in some special cases it is possible to develop criteria with a stronger 
theoretical support. If we can find a continuous function $\tilde{H}$ satisfying 
$H(\theta_{\infty}) = \tilde{H}(\theta_{\infty})$ and 
$$H(\theta_{\infty}) \geq \tilde{H}(\theta)$$
for all $\theta$  then 
$$0 \leq H(\theta_{n}) - H(\theta_{\infty}) \leq 
H(\theta_{n}) - \tilde{H}(\theta_{n}),$$ 
and the right hand side directly quantifies convergence. Convex duality 
theory gives for many convex optimization problems such a function, $\tilde{H}$,
and in those cases a convergence criterion based on $H(\theta_{n}) - \tilde{H}(\theta_{n})$ actually comes with a theoretical guarantee on
how close we are to the theoretical minimum.

## Descent direction algorithms

The negative gradient of $H$ in $\theta$ is the direction of steepest descent.
Starting from $\theta_0$ and with the goal of minimizing $H$, it is natural 
to move away from $\theta_0$ in the direction of $-\nabla H(\theta_0)$. 
Thus we could define  
$$\theta_1 = \theta_0 - \gamma \nabla H(\theta_0)$$
for a suitably chosen $\gamma > 0$. By Taylor's theorem 
$$H(\theta_1) = H(\theta_0) - \gamma \|\nabla H(\theta_0)\|^2_2 + o(\gamma),$$
which means that if $\theta_0$ is not a stationary point ($\nabla H(\theta_0) \neq 0$) 
then 
$$H(\theta_1) < H(\theta_0)$$
for $\gamma$ small enough.


More generally, we define a *descent direction* in $\theta_0$ 
as a vector $\rho_0 \in \mathbb{R}^p$ such that 
$$\nabla H(\theta_0)^T \rho_0 < 0.$$
By the same kind of Taylor argument as above, $H$ will descent for a sufficiently 
small step size in the direction of any descent direction. And if $\theta_0$
is not a stationary point, $-\nabla H(\theta_0)^T$ is a descent direction. 

One strategy for choosing $\gamma$ is to minimize the univariate 
function 
$$\gamma \mapsto H(\theta_0 + \gamma \rho_0),$$
which is an example of a *line search* method. Such a minimization 
would give the maximal possible descent in the direction $\rho_0$,
and as we have argued, if $\rho_0$ is a descent direction, a minimizer $\gamma > 0$
guarantees descent of $H$. However, unless the minimization can be 
done analytically it is often computationally too expensive. 
Less will also do, and as shown in Example \@ref(exm:grad-descent),
if the Hessian has uniformly bounded numerical radius it is possible to 
fix one (sufficiently small) step length that will guarantee descent. 

### Line search

We consider algorithms of the form 
$$\theta_{n+1} = \theta_n + \gamma_{n} \rho_n$$
for descent directions $\rho_n$ and starting in $\theta_0$. 
The step lengths, $\gamma_n$, are chosen so as to give 
sufficient descent in each iteration. 

We let $h(\gamma) = H(\theta_{n} + \gamma \rho_{n})$ 
denote the univariate and differentiable function of $\gamma$,
$$h : [0,\infty) \to \mathbb{R},$$ 
that gives the value of $H$ in the direction of the descent direction
$\rho_n$. We can observe that 
$$h'(\gamma) = \nabla H(\theta_{n} + \gamma \rho_{n})^T \rho_{n},$$
and maximal descent in direction $\rho_n$ can be found by solving
$h'(\gamma) = 0$ for $\gamma$. As mentioned above, less will do. First note
that 
$$h'(0) = \nabla H(\theta_{n})^T \rho_{n} < 0,$$
so $h$ has a negative slope in $0$. It descents in a sufficiently 
small interval $[0, \varepsilon)$, and it is even true that for any $c \in (0, 1)$
there is an $\varepsilon > 0$ such that
$$h(\gamma) \leq h(0) + c \gamma h'(0)$$
for $\gamma \in [0, \varepsilon)$. We note that this inequality can 
be checked easily for any given $\gamma > 0$, and is known as the 
*sufficient descent* condition. Sufficient descent is not enough 
in itself as the step length could be arbitrarily small, and the algorithm 
could effectively get stuck.  

To prevent too small steps we can enforce another condition. Very close 
to $0$, $h$ will have almost the same slope, $h'(0)$, as it has in $0$. If we 
therefore require that the slope in $\gamma$ should be larger than $\tilde{c} h'(0)$
for some $\tilde{c} \in (0, 1)$, $\gamma$ is forced away from $0$. This is 
known as the *curvature condition*. 

The combined conditions on $\gamma$, 
$$h(\gamma) \leq h(0) + c \gamma h'(0)$$
for a $c \in (0, 1)$ and 
$$h'(\gamma) \geq \tilde{c} h'(0)$$
for a $\tilde{c} \in (c, 1)$ are known collectively as 
the *Wolfe conditions*. It can be shown that if $h$ is bounded below there 
exists a step length satisfying the Wolfe conditions (Lemma 3.1 in @Nocedal:2006).

Even when choosing $\gamma_{n}$ to fulfill
the Wolfe conditions there is no guarantee that $\theta_n$
will converge let alone converge toward a global minimizer. The best we
can hope for in general is that 
$$\|\nabla H(\theta_n)\|_2 \rightarrow 0$$
for $n \to \infty$, and this will happen under some relatively weak 
conditions on $H$ (Theorem 3.2 @Nocedal:2006) under the assumption 
that 
$$\frac{\nabla H(\theta_n)^T \rho_n}{\|\nabla H(\theta_n)\|_2 \| \rho_n\|_2} \leq - \delta < 0.$$
That is, the angle between the descent direction and the gradient should be 
uniformly bounded away from $90^{\circ}$. 

A practical way of searching for a step length is via *backtracking*. 
Choosing a $\gamma_0$ and a constant $d \in (0, 1)$ we 
can search through the sequence of step lengths 
$$\gamma_0, d \gamma_0, d^2 \gamma_0, d^3 \gamma_0, \ldots$$
and stop the first time we find a step length satisfying the Wolfe 
conditions.

Using backtracking, we can actually dispense of the curvature condition 
and simply check the sufficient descent condition

$$H(\theta_{n} + d^k \gamma_0 \rho_{n}) \leq H(\theta_n) + cd^k \gamma_0 \nabla H(\theta_{n})^T \rho_{n}$$

for $c \in (0, 1)$. The implementation of backtracking requires the choice 
of the three parameters: $\gamma_0 > 0$, $d \in (0, 1)$ and $c \in (0, 1)$.
A good choice depends quite a lot on the algorithm used for choosing
the descent direction, but choosing $c$ too close to 1 can make the algorithm 
take too small steps, and taking $d$ too small can likewise 
generate small step lengths. Thus $d = 0.8$ or $d = 0.9$ 
and $c = 0.1$ or even smaller are sensible choices. For some algorithms, 
like the Newton algorithm to be dealt with below, there is a natural 
choice of $\gamma_0 = 1$. But for other algorithms a good choice depends 
crucially on the scale of the parameters, and there is then no general 
advice on choosing $\gamma_0$ that can be justified theoretically.

### Gradient descent 

We return to the Poisson regression example and implement functions 
in R for computing the negative log-likelihood and its gradient.
We exploit the `model.matrix` function to construct the model matrix 
from the data via a formula. The sufficient statistic is 
computed upfront, and the implementations use this vector
and relies on linear algebra and vectorized computations. We 
choose to normalize by the number of observations $n$ (the number
of rows in the model matrix). This does have a small computational 
cost, but the resulting numerical values become less dependent 
upon $n$, which makes it easier to choose sensible default values 
of various parameters for the numerical optimization algorithms.

```{r implement, dependson="vegetables-data"}
X <- model.matrix(sale ~ log(normalSale), data = vegetables)
y <- vegetables$sale
# The function drop() drops the dim attribute and turns, for instance,
# a matrix with one column into a vector
t_map <- drop(crossprod(X, y))  # More efficient than drop(t(X) %*% y)

H <- function(beta) 
  (drop(sum(exp(X %*% beta)) - beta %*% t_map)) / nrow(X)

grad_H <- function(beta) 
  (colSums(drop(exp(X %*% beta)) * X) - t_map) / nrow(X)
```

We implement a gradient descent algorithm with backtracking
that uses the *squared* norm of the gradient as a stopping criterion. 
For gradient descent, the sufficient descent condition amounts to 
choosing the smallest $k \geq 0$ such that 

$$H(\theta_{n} + d^k \gamma_0 \nabla H(\theta_{n})) \leq H(\theta_n) -  cd^k \gamma_0 \|\nabla H(\theta_{n})\|_2^2.$$

We include a callback argument (the `cb` argument) in the implementation. 
If a function is passed to this argument, it will be evaluated in each iteration
of the algorithm. This gives us the possibility of logging or 
printing values of variables during evaluation, which can be highly useful 
for understanding the inner workings of the algorithm. Monitoring or logging 
intermediate values during the evaluation of code is often referred to as 
*tracing*. 

```{r GD}
GD <- function(
  par, 
  H,
  gr,
  d = 0.8, 
  c = 0.1, 
  gamma0 = 0.01, 
  epsilon = 1e-4, 
  maxit = 1000,
  cb = NULL
) {
  for(i in 1:maxit) {
    value <- H(par)
    grad <- gr(par)
    h_prime <- sum(grad^2)
    if(!is.null(cb)) cb()
    # Convergence criterion based on gradient norm
    if(h_prime <= epsilon) break
    gamma <- gamma0
    # First proposed descent step
    par1 <- par - gamma * grad
    # Backtracking while descent is insufficient
    while(H(par1) > value - c * gamma * h_prime) {
      gamma <- d * gamma
      par1 <- par - gamma * grad
    }
    par <- par1
  }
  if(i == maxit)
    warning("Maximal number, ", maxit, ", of iterations reached")
  par
}
```

Gradient descent is very slow for the large Poisson model with individual 
store effects, so we consider only the simple model with two parameters. 

```{r GD-test, dependson=c("Implement", "GD")}
pois_GD <- GD(rep(0, ncol(X)), H, grad_H)
```

The gradient descent implementation is tested by comparing the minimizer to
the estimated parameters as computed by `glm()`.

```{r GD-comp, dependson=c("GD-test", "pois-model-null"), echo=2:3, results='hold'}
old_options = options(digits=10)
as.numeric(coefficients(pois_model_null))  # as.numeric to strip names
as.numeric(pois_GD)
options(digits = old_options$digits)
```

We get the same result up to the first two decimals. The convergence 
criterion on our gradient descent algorithm was quite loose ($\varepsilon = 10^{-4}$,
which means that the norm of the gradient is smaller than $10^{-2}$ when 
the algorithm stops). This choice of $\varepsilon$ in combination with $\gamma_0 = 0.01$ 
implies that the algorithm stops when the gradient is so small that the changes 
are at most of norm $10^{-4}$. 

Comparing the resulting values of the negative log-likelihood shows agreement
up to the first five decimals, but we notice that the value for the 
parameters fitted using `glm` is just slightly smaller. 

```{r GD-object, dependson=c("Implement", "GD-test"), echo=2:3, results='hold'}
old_options = options(digits = 15)
H(coefficients(pois_model_null))
H(pois_GD)
options(digits = old_options$digits)
```

To investigate what actually went on inside the gradient descent 
algorithm we will use the callback argument to trace the internals 
of a class to `GD()`. The `tracer()` function from the CSwR package 
can be used to construct 
a tracer object with a `tracer()` function that we can pass as the callback 
argument.  The tracer object and its `tracer()` function work by storing 
information in the enclosing environment of `tracer()`. When used as 
the callback argument to e.g. `GD()` the `tracer()` function will look up 
variables in the evaluation environment of `GD()`, store them and 
print them if requested, and store run time information as well. 

When `GD()` has returned, the trace information can be accessed
via the `summary()` method for the tracer object. The tracer objects 
and their `tracer()` function should not be confused with the `trace()` 
function from the R base package, but the tracer object's `tracer()` function
can be passed as the `tracer` argument to `trace()` to interactively 
inject tracing code into any R function. Here, the tracer objects will 
only be used together with a callback argument.

We use the tracer object with our gradient descent implementation
and print trace information every 50th iteration. 

```{r GD-trace, dependson=c("tracer", "GD", "Implement", "vegetables-data")}
GD_tracer <- tracer(c("value", "h_prime", "gamma"), N = 50)
pois_GD <- GD(rep(0, ncol(X)), H, grad_H, cb = GD_tracer$tracer)
```

We see that the gradient descent algorithm runs for a little more than 350
iterations, and we can observe how the value of the negative log-likelihood is 
descending. We can also see that the step length $\gamma$ bounces between 
$0.004096 = 0.8^4 \times 0.01$ and 
$0.00512 = 0.8^3 \times 0.01$, thus the backtracking 
takes 3 to 4 iterations to find a step length with sufficient descent.
 
The printed trace does not reveal the run time information. The 
run time is measured for each iteration of the algorithm and the 
cumulative run time is of greater interest. This information
is, however, best inspected and computed after the algorithm has converged,
and it is computed and returned by the summary method for tracer objects.

```{r this-summary, dependson=c("tracer", "GD-trace")}
tail(summary(GD_tracer))
```

The trace information is stored in a list. The summary method transforms 
the trace information into a data frame with one row per iteration. We can also access 
individual entries of the list of trace information via subsetting. 

```{r GD-trace-sub, dependson=c("tracer", "GD-trace")}
GD_tracer[377] 
```


```{r GD-trace-plot, echo=FALSE, fig.cap="Gradient norm (left) and value of the negative log-likelihood (right) above the limit value $H(\\theta_{\\infty})$. The straight line is fitted to the data points except the first ten using least squares, and the rate is computed from this estimate and reported per ms.", dependson="GD-trace", out.width="100%", fig.width=8, fig.height=3, message=FALSE}
trace_GD <- summary(GD_tracer)

rate1 <- exp(coef(lm(log(h_prime) ~ I(1000 * .time), data = trace_GD, subset = 11:nrow(trace_GD))))[2]

p1 <- ggplot(data = trace_GD, aes(x = 1000 * .time, y = sqrt(h_prime))) +
  geom_point() + 
  scale_y_log10("Gradient norm") +
  xlab("Time (ms)") + 
  geom_smooth(method = "lm", se = FALSE, method.args = list(subset = 11:nrow(trace_GD))) + 
  geom_text(aes(x = 50, y = 10, label = paste("rate:", round(rate1, 3), "per ms")), data = data.frame())

value_Inf <- H(coefficients(pois_model_null))
rate2 <- exp(coef(lm(log(value - value_Inf) ~ I(1000 * .time), data = trace_GD, subset = 11:nrow(trace_GD))))[2]

p2 <- ggplot(data = trace_GD, aes(x = 1000 * .time, y = value - value_Inf)) +
  geom_point() + 
  scale_y_log10(expression(Value - Value[infinity])) +
  xlab("Time (ms)") + 
  geom_smooth(method = "lm", se = FALSE, method.args = list(subset = 11:nrow(trace_GD))) + 
  geom_text(aes(x = 50, y = 10, label = paste("rate:", round(rate2, 3), "per ms")), data = data.frame())

grid.arrange(p1, p2, ncol = 2)
```

```{r, echo=FALSE, eval=FALSE}

rate3 <- exp(coef(lm.fit(cbind(1, 11:nrow(trace_GD)), log(trace_GD$h_prime[11:nrow(trace_GD)])))[2])

delta <- trace_GD$.time[nrow(trace_GD)] / nrow(trace_GD)

plot(diff(trace_GD$.time), ylim = c(0, 0.0003))
abline(h = delta, col = "red")
rate3^(1/(1000 * delta))
```


### Conjugate gradients

The gradient direction is not the best descent direction. It is too 
local, and convergence can be quite slow. One of the better algorithms that 
is still a "first order algorithm" (using only gradient information) is the [*nonlinear conjugate
gradient*](https://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method) algorithm. 
In the Fletcher--Reeves version of the algorithm
the descent direction is initialized as the negative gradient
$\rho_0 = - \nabla H(\theta_{0})$ and then updated as
$$\rho_{n} = - \nabla H(\theta_{n}) + \frac{\|\nabla H(\theta_n)\|_2^2}{\|\nabla H(\theta_{n-1})\|_2^2} \rho_{n-1}.$$
That is, the descent direction, $\rho_{n}$, is the negative gradient but modified according to 
the previous descent direction. There is plenty of opportunity to vary the prefactor 
of $\rho_{n-1}$, and the one presented here is what makes it the Fletcher--Reeves
version. Other versions go by the names of their inventors such as Polak–Ribière
or Hestenes--Stiefel.

In fact, $\rho_{n}$ need not be a descent direction unless we put some 
restrictions on the step lengths. One possibility is to require that
the step length $\gamma_{n}$ satisfies the *strong* curvature condition
$$|h'(\gamma)| = |\nabla H(\theta_n + \gamma \rho_n)^T \rho_n | \leq \tilde{c} |\nabla H(\theta_n)^T \rho_n| = \tilde{c} |h'(0)|$$
for a $\tilde{c} < \frac{1}{2}$. Then $\rho_{n + 1}$ can be shown to be a descent 
direction if $\rho_{n}$ is. 

We implement the conjugate gradient method in a slightly different way. Instead
of introducing the more advanced curvature condition, we simply reset the 
algorithm to use the gradient direction in any case where a non-descent direction
has been chosen. Resets of descent direction every $p$-th iteration is recommended 
anyway for the nonlinear conjugate gradient algorithm.

```{r CG}
CG <- function(
  par, 
  H,
  gr,
  d = 0.8, 
  c = 0.1, 
  gamma0 = 1, 
  epsilon = 1e-6,
  maxit = 1000,
  cb = NULL
) {
  p <- length(par)
  m <- 1
  rho0 <- numeric(p)
  for(i in 1:maxit) {
    value <- H(par)
    grad <- gr(par)
    grad_norm_sq <- sum(grad^2)
    if(!is.null(cb)) cb()
    if(grad_norm_sq <= epsilon) break
    gamma <- gamma0
    # Descent direction
    rho <- - grad + grad_norm_sq * rho0
    h_prime <- drop(t(grad) %*% rho)
    # Reset to gradient descent if m > p or rho is not a descent direction
    if(m > p || h_prime >= 0) {
      rho <- - grad
      h_prime <- - grad_norm_sq 
      m <- 1
    }
    par1 <- par + gamma * rho
    # Backtracking
    while(H(par1) > value + c * gamma * h_prime) {
      gamma <- d * gamma
      par1 <- par + gamma * rho
    }
    rho0 <- rho / grad_norm_sq
    par <- par1
    m <- m + 1
  }
  if(i == maxit)
    warning("Maximal number, ", maxit, ", of iterations reached")
  par
}
```


```{r CG-test-null, echo=2:3, dependson=c("Implement", "tracer", "vegetables-data", "CG")}
old_options = options(digits = 5)
CG_tracer <- tracer(c("value", "gamma", "grad_norm_sq"), N = 10)
pois_CG <- CG(rep(0, ncol(X)), H, grad_H, cb = CG_tracer$tracer)
options(digits = old_options$digits)
```

```{r GD-CG-trace-plot, echo=FALSE, fig.cap="Gradient norms (top) and negative log-likelihoods (bottom) for gradient descent (left) and conjugate gradient (right).", fig.height=6, fig.width=8, dependson=c("CG-test-null", "GD-trace-plot"), out.width="100%", message=FALSE}
trace_CG <- summary(CG_tracer)

rate3 <- exp(coef(lm(log(grad_norm_sq) ~ I(1000 * .time), data = trace_CG, subset = 11:nrow(trace_CG))))[2]

p3 <- ggplot(data = trace_CG, aes(x = 1000 * .time, y = sqrt(grad_norm_sq))) +
  geom_point() + 
  scale_y_log10("Gradient norm") +
  xlab("") + 
  geom_smooth(method = "lm", se = FALSE, method.args = list(subset = 11:nrow(trace_CG))) + 
  geom_text(aes(x = 45, y = 10, label = paste("rate:", round(rate3, 3), "per ms")), data = data.frame())

value_Inf <- H(coefficients(pois_model_null))
rate4 <- exp(coef(lm(log(value - value_Inf) ~ I(1000 * .time), data = trace_CG, subset = 11:nrow(trace_CG))))[2]

p4 <- ggplot(data = trace_CG, aes(x = 1000 * .time, y = value - value_Inf)) +
  geom_point() + 
  scale_y_log10(expression(Value - Value[infinity])) +
  xlab("Time (ms)") + 
  geom_smooth(method = "lm", se = FALSE, method.args = list(subset = 11:nrow(trace_CG))) + 
  geom_text(aes(x = 45, y = 10, label = paste("rate:", round(rate4, 3), "per ms")), data = data.frame())

cc1 <- coord_cartesian(xlim = c(0, 70), ylim = c(1e-4, 100))
cc2 <- coord_cartesian(xlim = c(0, 70), ylim = c(1e-10, 100))
grid.arrange(p1 + cc1 + ggtitle("Gradient descent") + xlab(""), 
             p3 + cc1 + ggtitle("Conjugate gradient"), 
             p2 + cc2, p4 + cc2, nrow = 2)
```


This algorithm is fast enough to fit the large Poisson regression model.

```{r X-update, dependson=c("Implement", "vegetables-data")}
X <- model.matrix(sale ~ store + log(normalSale) - 1, data = vegetables)
t_map <- drop(crossprod(X, y)) 
```

```{r CG-test, echo=2:3, dependson=c("Implement", "X-update", "tracer", "vegetables-data", "CG")}
old_options = options(digits = 5)
CG_tracer <- tracer(c("value", "gamma", "grad_norm_sq"), N = 100)
pois_CG <- CG(rep(0, ncol(X)), H, grad_H, cb = CG_tracer$tracer)
options(digits = old_options$digits)
```

```{r CG-tracer-summary, dependson = "CG-test"}
tail(summary(CG_tracer))
```

Using `optim()` with the conjugate gradient method.

```{r CG-optim, dependson=c("X-update", "implement")}
system.time(
  pois_optim_CG <- optim(
    rep(0, length = ncol(X)), 
    H, 
    grad_H, 
    method = "CG", 
    control = list(maxit = 10000)
  )
)
```

```{r CG-results, dependson="CG-optim"}
pois_optim_CG[c("value", "counts")]
```

### Peppered Moths {#pep-moth-descent}

Returning to the peppered moth from Section \@ref(pep-moth) we implemented 
in that section the log-likelihood for general multinomial cell collapsing
and applied the implementation to compute the maximum-likelihood estimate. 
In this section we implement the gradient as well. From the 
expression for the log-likelihood in \@ref(eq:mult-col-loglik) it follows
that the gradient equals

$$\nabla \ell(\theta) = \sum_{j = 1}^{K_0}  \frac{ x_j }{ M(p(\theta))_j}\nabla M(p(\theta))_j = \sum_{j = 1}^{K_0} \sum_{k \in A_j}  \frac{ x_j}{ M(p(\theta))_j} \nabla p_k(\theta).$$

Letting $j(k)$ be defined by $k \in A_{j(k)}$ we see that the gradient 
can also be written as
 $$\nabla \ell(\theta) = \sum_{k=1}^K    \frac{x_{j(k)}}{ M(p(\theta))_{j(k)}} \nabla p_k(\theta) = \mathbf{\tilde{x}}(\theta) \mathrm{D}p(\theta),$$
 where $\mathrm{D}p(\theta)$ is the Jacobian of the parametrization $\theta \mapsto p(\theta)$,
 and $\mathbf{\tilde{x}}(\theta)$ is the vector with 
 $$\mathbf{\tilde{x}}(\theta)_k = \frac{ x_{j(k)}}{M(p(\theta))_{j(k)}}.$$
 

```{r grad-loglik-pep}
grad_loglik <- function(par, x, prob, Dprob, group) {
  p <- prob(par)
  if(is.null(p)) return(rep(NA, length(par)))
  - (x[group] / M(p, group)[group]) %*% Dprob(par)
}
```

The Jacobian needs to be implemented for the specific example 
of peppered moths. 

```{r pep-jacobian}
Dprob <- function(p) {
  p[3] <- 1 - p[1] - p[2]
  matrix(
    c(2 * p[1],             0, 
      2 * p[2],             2 * p[1], 
      2* p[3] - 2 * p[1],  -2 * p[1],
      0,                    2 * p[2],         
      -2 * p[2],            2 * p[3] - 2 * p[2], 
      -2 * p[3],           -2 * p[3]),
    ncol = 2, nrow = 6, byrow = TRUE)
}
```

We can then use the conjugate gradient algorithm to compute the 
maximum-likelihood estimate. 

```{r pep-CG,  dependson=c("moth_likelihood", "moth_prob", "moth_M", "grad-loglik-pep", "pep-jacobian")}
optim(c(0.3, 0.3), loglik, grad_loglik, x = c(85, 196, 341), 
      prob = prob, Dprob = Dprob, group = c(1, 1, 1, 2, 2, 3), 
      method = "CG")
```

The peppered Moth example is very simple. 
The log-likelihood can easily be computed, and we used this 
problem to illustrate ways of implementing a 
likelihood in R and how to use `optim` to maximize it. 

One of the likelihood implementations was very problem specific 
while the other more abstract and general, and we used the same general and abstract
approach to implement the gradient above. The gradient could then 
be used for other optimization algorithms, still using `optim`, such as 
conjugate gradient. In fact, you can use conjugate gradient without
computing and implementing the gradient.

```{r pep-CG-nograd, dependson=c("moth_likelihood", "moth_prob", "moth_M")}
optim(c(0.3, 0.3), loglik, x = c(85, 196, 341), 
      prob = prob, group = c(1, 1, 1, 2, 2, 3), 
      method = "CG")
```

If we don't implement a gradient, a numerical gradient is 
used by `optim`. This can very well result in a slower algorithm than if the 
gradient is implemented, but more seriously, in can result in convergence 
problems. This is because there is a subtle tradeoff between numerical 
accuracy and accuracy of the finite difference approximation used to
approximate the gradient. We didn't 
experience convergence problems in the example above, but one way to remedy such problems 
is to set the `parscale` or `fnscale` entries in the `control`
list argument to `optim`. 

In the following chapter the peppered moth example is used to illustrate 
the EM algorithm. It is important to understand that the EM algorithm doesn't 
rely on the ability to compute the likelihood or the gradient of the 
likelihood for that matter. In many real applications 
of the EM algorithm the computation of the likelihood is challenging or even 
impossible, thus most standard optimization algorithms will not be directly 
applicable. 

## Newton-type algorithms

The Newton algorithm is very similar to gradient descent
except that the gradient descent direction is replaced by
$$\rho_n = - D^2 H(\theta_n)^{-1} \nabla H(\theta_n).$$

The Newton algorithm is typically much more efficient than gradient 
descent and will converge in few iterations. However, the storage of the 
$p \times p$ Hessian, its computation, and the solution of the equation
to compute $\rho_n$ all scale like $p^2$ and this can make the algorithm useless 
for very large $p$. 

A variety of alternatives to the Newton algorithm exist that replace
the Hessian by another matrix that can be easier to compute and update. 
It should be noted that if we choose a matrix $B_n$ in the $n$-th 
iteration, then $- B_n \nabla H(\theta_n)$
is a descent direction whenever $B_n$ is a positive definite matrix. 

Newton implementation (with trace).

```{r Newton}
Newton <- function(
  par, 
  H,
  gr,
  hess,
  d = 0.8, 
  c = 0.1, 
  gamma0 = 1, 
  epsilon = 1e-10, 
  maxit = 50,
  cb = NULL
) {
  for(i in 1:maxit) {
    value <- H(par)
    grad <- gr(par)
    if(!is.null(cb)) cb()
    if(sum(grad^2) <= epsilon) break
    Hessian <- hess(par) 
    rho <- - drop(solve(Hessian, grad)) 
    gamma <- gamma0
    par1 <- par + gamma * rho
    h_prime <- t(grad) %*% rho 
    while(H(par1) > value +  c * gamma * h_prime) { 
      gamma <- d * gamma 
      par1 <- par + gamma * rho
    }
    par <- par1 
  }
  if(i == maxit)
    warning("Maximal number, ", maxit, ", of iterations reached")
  par
}
```


### Poisson regression 

It requires the implementation of the Hessian matrix. 

```{r Hessian}
Hessian_H <- function(beta)
  (crossprod(X, drop(exp(X %*% beta)) * X)) / nrow(X)
```

```{r Newton-test, dependson=c("Implement", "Hessian", "vegetables-data", "X-update", "Newton")}
Newton_tracer <- tracer(c("value", "h_prime", "gamma"), N = 1)
pois_Newton <- Newton(
  rep(0, ncol(X)), 
  H,
  grad_H,
  Hessian_H,
  cb = Newton_tracer$tracer
)
```


```{r Newton-comp, dependson=c("Newton-test", "pois-model")}
range(pois_Newton - pois_model$coefficients)
```

```{r Newton-object, dependson=c("Implement", "Newton-test", "pois-model"), echo=2:3}
old_options = options(digits = 20)
H(pois_Newton)
H(coefficients(pois_model))
options(digits = old_options$digits)
```

```{r Newton-tracer-summary, dependson=c("Newton-test", "tracer")}
summary(Newton_tracer)
```

The R function `glm.fit()` uses a Newton algorithm (without backtracking) 
and is about a factor five faster on this example. 

```{r pois-glm.fit, dependson=c("Implement", "Newton-test")}
system.time(glm.fit(X, y, family = poisson()))
```

One should be careful when comparing run times for different optimization 
algorithms, but in this case they have achieved about the same precision 
with the faster `glm.fit()` that even obtained the smallest negative
log-likelihood value of the two.

### Quasi-Newton algorithms

We turn to other descent direction algorithms that are more efficient 
than gradient descent by choosing the descent direction in a more 
clever way but less computationally demanding than the Newton 
algorithm that requires the computation of the full Hessian in each 
iteration. 

We will only consider the application of the BFGS algorithm via the 
implementation in the R function `optim()`.

```{r BFGS, dependson=c("X-update", "implement")}
system.time(
  pois_BFGS <- optim(
    rep(0, length = ncol(X)), 
    H, 
    grad_H, 
    method = "BFGS", 
    control = list(maxit = 10000)
  )
)
```

```{r BFGS-results, dependson="BFGS"}
range(pois_BFGS$par - coefficients(pois_model))
pois_BFGS[c("value", "counts")]
```

### Sparsity

One of the benefits of the implementations of $H$ and its derivatives
as well as of the descent algorithms is that they can exploit sparsity
of $\mathbf{X}$ almost for free. The implementations have not done that in 
previous computations, because $\mathbf{X}$ has been stored as a dense matrix. In 
reality, $\mathbf{X}$ is a very sparse matrix (the vast majority of the matrix 
entries are zero), 
and if we convert it into a sparse matrix, all the matrix-vector products 
will be more run time efficient. Sparse matrices are implemented in the 
R package Matrix. 

```{r Matrix, cache=FALSE}
library(Matrix)
```

```{r sparse, dependson="X-update"}
X <- Matrix(X)
```

Without changing any other code, we get an immediate 
run time improvement using e.g. `optim()` and the BFGS algorithm.

```{r BFGS-sparse, dependson=c("X-update", "implement", "sparse")}
system.time(
  pois_BFGS_sparse <- optim(
    rep(0, length = ncol(X)), 
    H, 
    grad_H, 
    method = "BFGS", 
    control = list(maxit = 10000)
  )
)
```

We should in real applications avoid constructing a dense intermediate 
model matrix as a step toward constructing a sparse model matrix. This 
is possible by constructing the sparse model matrix directly using 
a function from the R package MatrixModels.

```{r sparse-model-matrix, dependson="vegetables-data"}
library(MatrixModels)
X <- model.Matrix(
  sale ~ store + log(normalSale) - 1, 
  data = vegetables, 
  sparse = TRUE
)
class(X)
```

The Newton implementation benefits enormously from using sparse matrices
because the bottleneck is the computation of the Hessian. 

```{r time-sparse-model-matrix, echo=2:4, dependson=c("Implement", "Hessian", "Newton", "tracer", "sparse-model-matrix")}
pois_Newton <- Newton(rep(0, ncol(X)), H, grad_H, Hessian_H)  ## Ensures more correct timings, perhaps due to lazy-loading?
Newton_tracer <- tracer(c("value", "h_prime", "gamma"), N = 0)
pois_Newton <- Newton(
  rep(0, ncol(X)),
  H, 
  grad_H,
  Hessian_H,
  cb = Newton_tracer$tracer
)
summary(Newton_tracer)
```

Run time efficiency is not the only argument for using sparse matrices as they are 
also more memory efficient. It is memory (and time) inefficient to use dense intermediates, 
and for truly large scale problems impossible. Using sparse model matrices 
for regression models allows us to work with larger models that have 
more variables, more factor levels and more observations than if we use dense
model matrices. For the Poisson regression model the memory used by either representation can be found. 

```{r X-size, dependson="sparse-model-matrix", echo=c(2, 4), results='hold'}
cat("Sparse matrix memory usage:\n")
object.size(X)
cat("Dense matrix memory usage:\n")
object.size(as.matrix(X))
```

We see that the dense matrix uses around a factor 30 more memory than the 
sparse representation. In this case it means using around 3 MB for storing the 
dense matrix instead of around 100 kB, which won't be a problem 
on a contemporary computer. However, going from using 3 GB for
storing a matrix to using 100 Mb could be the difference between 
not being able to work with the matrix on a standard laptop to
running the computations with no problems. Using `model.Matrix` makes
it possible to construct sparse model matrices directly and avoid 
all dense intermediates. This is exploited in the `glm4()` function from 
the MatrixModels package for fitting regression models, which can 
thus be useful in cases where your model matrix becomes very large but sparse. 
There are two main cases where the model matrix becomes sparse. 
When you model the response using one or more factors, and possibly their 
interactions, the model matrix will become particularly sparse if 
the factors have many levels. Another case is when you model the response 
via basis expansions of quantitative predictors and use basis functions 
with local support. The B-splines form an important example of such a basis
with local support that results in a sparse model matrix.  


## Misc.

If $\Phi$ is just *nonexpansive* (the 
constant $c$ above is one), this is no longer true, but replacing $\Phi$ 
by $\alpha \Phi + (1 - \alpha) I$ for $\alpha \in (0,1)$ we get 
Krasnoselskii-Mann iterates of the form 
$$\theta_n = \alpha \Phi(\theta_{n-1}) + (1 - \alpha) \theta_{n-1}$$
that will converge to a fixed point of $\Phi$ provided it has one. 

Iteration, fixed points, convergence criteria. Ref to [Nonlinear Parameter Optimization Using R Tools](http://onlinelibrary.wiley.com/book/10.1002/9781118884003).