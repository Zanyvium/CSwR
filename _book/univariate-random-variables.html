<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 4 Univariate random variables | Computational Statistics with R</title>
<meta name="author" content="Niels Richard Hansen">
<meta name="description" content="This chapter will deal with algorithms for simulating observations from a distribution on \(\mathbb{R}\) or any subset thereof. There can be several purposes of doing so, for instance: We want to...">
<meta name="generator" content="bookdown 0.24 with bs4_book()">
<meta property="og:title" content="Chapter 4 Univariate random variables | Computational Statistics with R">
<meta property="og:type" content="book">
<meta property="og:description" content="This chapter will deal with algorithms for simulating observations from a distribution on \(\mathbb{R}\) or any subset thereof. There can be several purposes of doing so, for instance: We want to...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 4 Univariate random variables | Computational Statistics with R">
<meta name="twitter:description" content="This chapter will deal with algorithms for simulating observations from a distribution on \(\mathbb{R}\) or any subset thereof. There can be several purposes of doing so, for instance: We want to...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.10/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/_Roboto%20Slab-0.4.0/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.3.0/transition.js"></script><script src="libs/bs3compat-0.3.0/tabs.js"></script><script src="libs/bs3compat-0.3.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Computational Statistics with R</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Preface</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Introduction</a></li>
<li class="book-part">Part I: Smoothing</li>
<li><a class="" href="density.html"><span class="header-section-number">2</span> Density estimation</a></li>
<li><a class="" href="bivariate.html"><span class="header-section-number">3</span> Bivariate smoothing</a></li>
<li class="book-part">Part II: Monte Carlo Methods</li>
<li><a class="active" href="univariate-random-variables.html"><span class="header-section-number">4</span> Univariate random variables</a></li>
<li><a class="" href="mci.html"><span class="header-section-number">5</span> Monte Carlo integration</a></li>
<li class="book-part">Part III: Optimization</li>
<li><a class="" href="four-examples.html"><span class="header-section-number">6</span> Four Examples</a></li>
<li><a class="" href="numopt.html"><span class="header-section-number">7</span> Numerical optimization</a></li>
<li><a class="" href="em.html"><span class="header-section-number">8</span> Expectation maximization algorithms</a></li>
<li><a class="" href="StochOpt.html"><span class="header-section-number">9</span> Stochastic Optimization</a></li>
<li><a class="" href="the-stochastic-em-algorithm.html"><span class="header-section-number">10</span> The stochastic EM algorithm</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="app-R.html"><span class="header-section-number">A</span> R programming</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/nielsrhansen/CSwR">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="univariate-random-variables" class="section level1" number="4">
<h1>
<span class="header-section-number">4</span> Univariate random variables<a class="anchor" aria-label="anchor" href="#univariate-random-variables"><i class="fas fa-link"></i></a>
</h1>
<p>This chapter will deal with algorithms for simulating observations from a
distribution on <span class="math inline">\(\mathbb{R}\)</span> or any subset thereof. There can be several
purposes of doing so, for instance:</p>
<ul>
<li>We want to investigate properties of the distribution.</li>
<li>We want to simulate independent realizations of univariate random variables to
investigate the distribution of a transformation.</li>
<li>We want to use Monte Carlo integration to compute numerically an integral
(which could be a probability).</li>
</ul>
<p>In this chapter the focus is on the simulation of a single random variable
or an i.i.d. sequence of random variables primarily via various transformations
of pseudorandom numbers. The pseudo
random numbers themselves being approximate simulations of i.i.d. random
variables uniformly distributed on <span class="math inline">\((0, 1)\)</span>.</p>
<div id="pseudorandom-number-generators" class="section level2" number="4.1">
<h2>
<span class="header-section-number">4.1</span> Pseudorandom number generators<a class="anchor" aria-label="anchor" href="#pseudorandom-number-generators"><i class="fas fa-link"></i></a>
</h2>
<p>Most simulation algorithms are based on algorithms for generating
<em>pseudorandom</em> uniformly distributed variables in <span class="math inline">\((0, 1)\)</span>. They arise from
deterministic integer sequences initiated by a <em>seed</em>. A classical
example of a pseudorandom integer generator is the
linear congruential generator. A sequence of numbers from
this generator is computed iteratively by
<span class="math display">\[x_{n+1} = (a x_n + c)  \text{ mod m}\]</span>
for integer parameters <span class="math inline">\(a\)</span>, <span class="math inline">\(c\)</span> and <span class="math inline">\(m\)</span>. The seed <span class="math inline">\(x_1\)</span> is a
number between <span class="math inline">\(0\)</span> and <span class="math inline">\(m - 1\)</span>, and the resulting
sequence is in the set <span class="math inline">\(\{0, \ldots, m - 1\}\)</span>. The ANSI C standard specifies
the choices <span class="math inline">\(m = 2^{31}\)</span>, <span class="math inline">\(a = 1,103,515,245\)</span> and <span class="math inline">\(c = 12,345\)</span>. The generator
is simple to understand and implement but has been superseded by much better
generators.</p>
<p>Pseudorandom number generators are generally defined in terms of a finite state space
<span class="math inline">\(\mathcal{Z}\)</span> and a one-to-one map <span class="math inline">\(f : \mathcal{Z} \to \mathcal{Z}\)</span>. The
generator produces a sequence in <span class="math inline">\(\mathcal{Z}\)</span> iteratively from the
seed <span class="math inline">\(\mathbf{z}_1 \in \mathcal{Z}\)</span> by
<span class="math display">\[\mathbf{z}_n = f(\mathbf{z}_{n-1}).\]</span>
Pseudorandom integers are typically obtained as
<span class="math display">\[x_n = h(\mathbf{z}_n)\]</span>
for a transformation <span class="math inline">\(h : \mathcal{Z} \mapsto \mathbb{Z}\)</span>. If the
image of <span class="math inline">\(h\)</span> is in the set <span class="math inline">\(\{0, 1, \ldots, 2^{w} - 1\}\)</span> of <span class="math inline">\(w\)</span>-bit integers,
pseudorandom numbers in <span class="math inline">\([0, 1)\)</span> are typically obtained as
<span class="math display">\[x_n = 2^{-w} h(\mathbf{z}_n).\]</span></p>
<p>In R, the default pseudorandom number generator is the 32-bit
<em>Mersenne Twister</em>, which generates integers in the range
<span class="math display">\[\{0, 1, \ldots, 2^{32} -1\}.\]</span> The state space is
<span class="math display">\[\mathcal{Z} =  \{0, 1, \ldots, 2^{32} -1\}^{624},\]</span>
that is, a state is a 624 dimensional vector of 32-bit integers.
The function <span class="math inline">\(f\)</span> is of the form
<span class="math display">\[f(\mathbf{z}) = (z_2, z_3, \ldots, z_{623}, f_{624}(z_1, z_2, z_{m + 1})),\]</span>
for <span class="math inline">\(1 \leq m &lt; 624\)</span>, and <span class="math inline">\(h\)</span> is a function of <span class="math inline">\(z_{624}\)</span> only.
The standard choice <span class="math inline">\(m = 397\)</span> is used in the R implementation.
The function <span class="math inline">\(f_{624}\)</span> is a bit complicated, it includes
what is known as the <em>twist transformation</em>, and it requires
additional parameters. The period of the generator
is the astronomical number
<span class="math display">\[2^{32 \times 624 - 31} - 1 = 2^{19937} - 1,\]</span>
which is a Mersenne prime.
Moreover, all combinations of consecutive integers
up to dimension 623 occur equally often in a period, and empirical tests of the
generator demonstrate that it has good statistical properties, though it
is known to fail some tests.</p>
<p>In R you can set the seed using the function <code>set.seed</code> that takes an
integer argument and produces an element in the state space. The argument
given to <code>set.seed</code> is not the actual seed, and <code>set.seed</code> computes a
valid seed for any pseudorandom number generator that R is using,
whether it is the Mersenne Twister or not. Thus the use of <code>set.seed</code> is
the safe and recommended way of setting a seed.</p>
<p>The actual seed (together with some additional information) can be accessed
via the vector <code>.Random.seed</code>. Its first entry, <code>.Random.seed[1]</code>, encodes the
pseudorandom number generator used as well as the generator for
Gaussian variables and discrete uniform variables. This
information is decoded by <code><a href="https://rdrr.io/r/base/Random.html">RNGkind()</a></code>.</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">RNGkind</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "Mersenne-Twister" "Inversion"        "Rejection"</code></pre>
<p>For the Mersenne Twister,
<code>.Random.seed[3:626]</code> contains the vector in the state space, while
<code>.Random.seed[2]</code> contains the “current position” in the state vector.
The implementation needs a position variable because it does 624 updates of the
state vector at a time and then runs through those values sequentially
before the next update. This is equivalent to but more efficient than e.g.
implementing the position shifts explicitly as in the definition of <span class="math inline">\(f\)</span> above.</p>
<div class="sourceCode" id="cb111"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">27112015</span><span class="op">)</span>           <span class="co">## Computes a new seed from an integer</span>
<span class="va">oldseed</span> <span class="op">&lt;-</span> <span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>  <span class="co">## The actual seed</span>
<span class="va">.Random.seed</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>              <span class="co">## Encoding of generators used, will stay fixed</span></code></pre></div>
<pre><code>## [1] 10403</code></pre>
<div class="sourceCode" id="cb113"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">.Random.seed</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>              <span class="co">## Start position after the seed has been set is 624</span></code></pre></div>
<pre><code>## [1] 624</code></pre>
<div class="sourceCode" id="cb115"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>
<span class="va">tmp</span></code></pre></div>
<pre><code>## [1] 0.7793288</code></pre>
<p>Every time a random number is generated, e.g. by <code>runif</code> above, the same underlying
sequence of pseudorandom numbers is used, and the state vector stored in
<code>.Random.seed</code> is updated accordingly.</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">oldseed</span>, <span class="fl">5</span><span class="op">)</span></code></pre></div>
<pre><code>## [1]         624 -1660633125 -1167670944  1031453153   815285806</code></pre>
<div class="sourceCode" id="cb119"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, <span class="fl">5</span><span class="op">)</span>     <span class="co">## The state vector and position has been updated</span></code></pre></div>
<pre><code>## [1]           1  -696993996 -1035426662  -378189083  -745352065</code></pre>
<div class="sourceCode" id="cb121"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">tmp</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>          </code></pre></div>
<pre><code>## [1] 0.7793288 0.5613179</code></pre>
<div class="sourceCode" id="cb123"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, <span class="fl">5</span><span class="op">)</span>     <span class="co">## The state vector has not changed, only the position</span></code></pre></div>
<pre><code>## [1]           2  -696993996 -1035426662  -378189083  -745352065</code></pre>
<p>Resetting the seed will restart the pseudorandom number generator with the
same seed and result in the same sequence of random numbers.</p>
<div class="sourceCode" id="cb125"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">27112015</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, <span class="fl">5</span><span class="op">)</span></code></pre></div>
<pre><code>## [1]         624 -1660633125 -1167670944  1031453153   815285806</code></pre>
<div class="sourceCode" id="cb127"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">oldseed</span>, <span class="fl">5</span><span class="op">)</span>             <span class="co">## Same as current .Random.seed</span></code></pre></div>
<pre><code>## [1]         624 -1660633125 -1167670944  1031453153   815285806</code></pre>
<div class="sourceCode" id="cb129"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>                     <span class="co">## Same as tmp</span></code></pre></div>
<pre><code>## [1] 0.7793288</code></pre>
<p>Note that when using any of the standard R generators, any value of <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>
returned by the underlying pseudorandom uniform generator is
adjusted to be in <span class="math inline">\((0,1)\)</span>. Thus uniform random variables are guaranteed to be
in <span class="math inline">\((0, 1)\)</span>.</p>
<p>Some of the random number generators implemented in R use more than one
pseudorandom number per variable. This is, for instance, the case when we simulate
Gamma distributed random variables.</p>
<div class="sourceCode" id="cb131"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">27112015</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>                 <span class="co">## A single Gamma distributed random number</span></code></pre></div>
<pre><code>## [1] 1.192619</code></pre>
<div class="sourceCode" id="cb133"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, <span class="fl">5</span><span class="op">)</span>    <span class="co">## Position changed to 2</span></code></pre></div>
<pre><code>## [1]           2  -696993996 -1035426662  -378189083  -745352065</code></pre>
<div class="sourceCode" id="cb135"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>                 <span class="co">## A single Gamma distributed random number</span></code></pre></div>
<pre><code>## [1] 0.2794622</code></pre>
<div class="sourceCode" id="cb137"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, <span class="fl">5</span><span class="op">)</span>    <span class="co">## Position changed to 5</span></code></pre></div>
<pre><code>## [1]           5  -696993996 -1035426662  -378189083  -745352065</code></pre>
<p>In the example above, the first Gamma variable required two pseudorandom
numbers, while the second required three pseudorandom numbers. The detailed
explanation is given in Section <a href="univariate-random-variables.html#reject-samp">4.3</a>, where it is shown
how to generate random variables from the Gamma distribution via
rejection sampling. This requires as a minimum two pseudorandom numbers
for every Gamma variable generated.</p>
<div id="implementing-a-pseudorandom-number-generator" class="section level3" number="4.1.1">
<h3>
<span class="header-section-number">4.1.1</span> Implementing a pseudorandom number generator<a class="anchor" aria-label="anchor" href="#implementing-a-pseudorandom-number-generator"><i class="fas fa-link"></i></a>
</h3>
<p>The development of high quality pseudorandom number generators is a
research field in itself. This is particularly true if one needs
theoretical guarantees for randomized algorithms or cryptographically
secure generators. For scientific computations and
simulations correct statistical properties, reproducibility and speed are
more important than cryptographic security, but even so, it is not trivial
to invent a good generator, and the field is still developing. For a
generator to be seriously considered, its mathematical properties should
be well understood, and it should pass (most) tests in standardized
test suites such as <a href="http://simul.iro.umontreal.ca/testu01/tu01.html">TestU01</a>,
see <span class="citation"><a href="references.html#ref-LEcuyer:2007" role="doc-biblioref">L’Ecuyer and Simard</a> (<a href="references.html#ref-LEcuyer:2007" role="doc-biblioref">2007</a>)</span>.</p>
<p>R provides a couple of alternatives to the Mersenne Twister,
see <code><a href="https://rdrr.io/r/base/Random.html">?RNG</a></code>, but there is no compelling reason to switch to any of those for ordinary
use. They are mostly available for historical reasons.
One exception is the L’Ecuyer-CMRG generator, which is useful when
independent pseudorandom sequences are needed for parallel computations.</p>
<p>Though the Mersenne Twister is a widely used pseudorandom number generator,
it has <a href="http://www.pcg-random.org/other-rngs.html">well known shortcomings</a>.
There are high quality alternatives that are simpler and faster, such
as the family of <a href="https://en.wikipedia.org/wiki/Xorshift">shift-register generators</a>
and their variations, but they are not currently available from the base R package.</p>
<p>Shift-register generators are based on linear transformations of the bit
representation of integers. Three particular transformations are typically
composed; the <span class="math inline">\(\mathrm{Lshift}\)</span> and <span class="math inline">\(\mathrm{Rshift}\)</span> operators and the
bitwise <span class="math inline">\(\mathrm{xor}\)</span> operator. Let <span class="math inline">\(z = [z_{31}, z_{30}, \ldots, z_0]\)</span>
with <span class="math inline">\(z_i \in \{0, 1\}\)</span> denote the bit
representation of a 32-bit (unsigned) integer <span class="math inline">\(z\)</span> (ordered from most significant
bit to least significant bit). That is,
<span class="math display">\[z = z_{31} 2^{31} + z_{30} 2^{30} + \ldots + z_2 2^2 + z_1 2^{1} + z_0.\]</span>
Then the left shift operator is defined as
<span class="math display">\[\mathrm{Lshift}(z) = [z_{30}, z_{29}, \ldots, z_0, 0],\]</span>
and the right shift operator is defined as
<span class="math display">\[\mathrm{Rshift}(z) = [0, z_{31}, z_{30}, \ldots, z_1].\]</span>
The bitwise xor operator is defined as
<span class="math display">\[\mathrm{xor}(z, z') = [\mathrm{xor}(z_{31},z_{31}') , 
\mathrm{xor}(z_{30}, z_{30}'), \ldots, \mathrm{xor}(z_0, z_0')]\]</span>
where <span class="math inline">\(\mathrm{xor}(0, 0) = \mathrm{xor}(1, 1) = 0\)</span> and
<span class="math inline">\(\mathrm{xor}(1, 0) = \mathrm{xor}(0, 1) = 1\)</span>. Thus a transformation could
be of the form
<span class="math display">\[\mathrm{xor}(z, \mathrm{Rshift}^2(z)) = [\mathrm{xor}(z_{31}, 0) , 
\mathrm{xor}(z_{30}, 0), \mathrm{xor}(z_{29}, z_{31}), \ldots, \mathrm{xor}(z_0, z_2)].\]</span></p>
<p>One example of a shift-register based generator is Marsaglia’s <a href="https://en.wikipedia.org/wiki/Xorshift#xorwow">xorwow</a>
algorithm, <span class="citation"><a href="references.html#ref-Marsaglia:2003" role="doc-biblioref">Marsaglia</a> (<a href="references.html#ref-Marsaglia:2003" role="doc-biblioref">2003</a>)</span>. In addition to the shift and xor operations, the output of
this generator is perturbed by a sequence of integers with period <span class="math inline">\(2^{32}\)</span>.
The state space of the generator is
<span class="math display">\[\{0, 1, \ldots, 2^{32} -1\}^{5}\]</span>
with
<span class="math display">\[f(\mathbf{z}) = (z_1 + 362437 \ (\mathrm{mod}\ 2^{32}),
f_1(z_5, z_2), z_2, z_3, z_4),\]</span>
and
<span class="math display">\[h(\mathbf{z}) = 2^{-32} (z_1 + z_2).\]</span>
The number 362437 is Marsaglia’s choice for generating what he calls a
Weyl sequence, but any odd number will do. The function <span class="math inline">\(f_1\)</span> is given as
<span class="math display">\[f_1(z, z') = \mathrm{xor}(\mathrm{xor}(z, \mathrm{Rshift}^2(z)), \mathrm{xor}(z', \mathrm{xor}(\mathrm{Lshift}^4(z'), \mathrm{Lshift}(\mathrm{xor}(z, \mathrm{Rshift}^2(z)))))).\]</span></p>
<p>This may look intimidating, but all the operations are very elementary.
Take the number <span class="math inline">\(z = 123456\)</span>, say, then the intermediate value
<span class="math inline">\(\overline{z} = \mathrm{xor}(z, \mathrm{Rshift}^2(z))\)</span> is computed as follows:</p>
<p><span class="math display">\[
\begin{array}{ll}
z &amp; \texttt{00000000 00000001 11100010 01000000} \\
\mathrm{Rshift}^2(z) &amp; \texttt{00000000 00000000 01111000 10010000} \\
\hline
\mathrm{xor} &amp; \texttt{00000000 00000001 10011010 11010000}
\end{array}
\]</span></p>
<p>And if <span class="math inline">\(z' = 87654321\)</span> the value of <span class="math inline">\(f_1(z, z')\)</span> is computed like this:</p>
<p><span class="math display">\[
\begin{array}{ll}
\mathrm{Lshift}^4(z') &amp; \texttt{01010011 10010111 11111011 00010000} \\
\mathrm{Lshift}(\overline{z}) &amp; \texttt{00000000 00000011 00110101 10100000} \\
\hline
\mathrm{xor} &amp; \texttt{01010011 10010100 11001110 10110000} \\
z' &amp; \texttt{00000101 00111001 01111111 10110001} \\
\hline
\mathrm{xor} &amp; \texttt{01010110 10101101 10110001 00000001} \\
\overline{z} &amp; \texttt{00000000 00000001 10011010 11010000} \\
\hline
 \mathrm{xor} &amp; \texttt{01010110 10101100 00101011 11010001}
\end{array}
\]</span></p>
<p>Converted back to a 32-bit integer, the result is <span class="math inline">\(f_1(z, z') = 1454123985\)</span>.
The shift and xor operations are tedious to do by hand but extremely fast on
modern computer architectures, and shift-register based generators are some
of the fastest generators with good statistical properties.</p>
<p>To make R use the xorwow generator we need to implement it as a user supplied
generator. This requires writing the C code that implements the generator,
compiling the code into a shared object file, loading it into
R with the <code>dyn.load</code> function, and finally calling <code><a href="https://rdrr.io/r/base/Random.html">RNGkind("user")</a></code>
to make R use this pseudorandom number generator. See <code><a href="https://rdrr.io/r/base/Random-user.html">?Random.user</a></code>
for some details and an example.</p>
<p>Using the Rcpp package, and <code>sourceCpp</code>, in particular, is usually much preferred
over manual compiling and loading. However, in this case we need to make
functions available to the internals of R rather than exporting functions to be
callable from the R console. That is, nothing needs to be exported from C/C++.
If nothing is exported, <code>sourceCpp</code> will actually not load the shared object
file, so we need to trick <code>sourceCpp</code> to do so anyway. In the implementation
below we achieve this by simply exporting a direct interface to the xorwow generator.</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="univariate-random-variables.html#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span></span>
<span id="cb139-2"><a href="univariate-random-variables.html#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;R_ext/Random.h&gt;</span></span>
<span id="cb139-3"><a href="univariate-random-variables.html#cb139-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-4"><a href="univariate-random-variables.html#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="co">/* The Random.h header file contains the function declarations for the functions </span></span>
<span id="cb139-5"><a href="univariate-random-variables.html#cb139-5" aria-hidden="true" tabindex="-1"></a><span class="co"> that R rely on internally for a user defined generator, and it also defines </span></span>
<span id="cb139-6"><a href="univariate-random-variables.html#cb139-6" aria-hidden="true" tabindex="-1"></a><span class="co"> the type Int32 as an unsigned int. */</span></span>
<span id="cb139-7"><a href="univariate-random-variables.html#cb139-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-8"><a href="univariate-random-variables.html#cb139-8" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> Int32 z[<span class="dv">5</span>];     <span class="co">// The state vector </span></span>
<span id="cb139-9"><a href="univariate-random-variables.html#cb139-9" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">double</span> res;</span>
<span id="cb139-10"><a href="univariate-random-variables.html#cb139-10" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">int</span> nseed = <span class="dv">5</span>;  <span class="co">// Length of the state vector</span></span>
<span id="cb139-11"><a href="univariate-random-variables.html#cb139-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-12"><a href="univariate-random-variables.html#cb139-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Implementation of xorwow from Marsaglia's "Xorshift RNGs" </span></span>
<span id="cb139-13"><a href="univariate-random-variables.html#cb139-13" aria-hidden="true" tabindex="-1"></a><span class="co">// modified so as to return a double in [0, 1). The '&gt;&gt;' and '&lt;&lt;' </span></span>
<span id="cb139-14"><a href="univariate-random-variables.html#cb139-14" aria-hidden="true" tabindex="-1"></a><span class="co">// operators in C are bitwise right and left shift operators, and </span></span>
<span id="cb139-15"><a href="univariate-random-variables.html#cb139-15" aria-hidden="true" tabindex="-1"></a><span class="co">// the caret, '^', is the xor operator. </span></span>
<span id="cb139-16"><a href="univariate-random-variables.html#cb139-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-17"><a href="univariate-random-variables.html#cb139-17" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> * user_unif_rand()</span>
<span id="cb139-18"><a href="univariate-random-variables.html#cb139-18" aria-hidden="true" tabindex="-1"></a>{ </span>
<span id="cb139-19"><a href="univariate-random-variables.html#cb139-19" aria-hidden="true" tabindex="-1"></a>  Int32 t = z[<span class="dv">4</span>];</span>
<span id="cb139-20"><a href="univariate-random-variables.html#cb139-20" aria-hidden="true" tabindex="-1"></a>  Int32 s = z[<span class="dv">1</span>];</span>
<span id="cb139-21"><a href="univariate-random-variables.html#cb139-21" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">0</span>] += <span class="dv">362437</span>;</span>
<span id="cb139-22"><a href="univariate-random-variables.html#cb139-22" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">4</span>] = z[<span class="dv">3</span>];</span>
<span id="cb139-23"><a href="univariate-random-variables.html#cb139-23" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">3</span>] = z[<span class="dv">2</span>];</span>
<span id="cb139-24"><a href="univariate-random-variables.html#cb139-24" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">2</span>] = s;</span>
<span id="cb139-25"><a href="univariate-random-variables.html#cb139-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Right shift t by 2, then bitwise xor between t and its shift</span></span>
<span id="cb139-26"><a href="univariate-random-variables.html#cb139-26" aria-hidden="true" tabindex="-1"></a>  t ^= t &gt;&gt; <span class="dv">2</span>;  </span>
<span id="cb139-27"><a href="univariate-random-variables.html#cb139-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Left shift t by 1 and s by 4, xor them, xor with s and xor with t</span></span>
<span id="cb139-28"><a href="univariate-random-variables.html#cb139-28" aria-hidden="true" tabindex="-1"></a>  t ^= s ^ (s &lt;&lt; <span class="dv">4</span>) ^ (t &lt;&lt; <span class="dv">1</span>);</span>
<span id="cb139-29"><a href="univariate-random-variables.html#cb139-29" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">1</span>] = t;</span>
<span id="cb139-30"><a href="univariate-random-variables.html#cb139-30" aria-hidden="true" tabindex="-1"></a>  res = (z[<span class="dv">0</span>] + t) * <span class="fl">2.32830643653869e-10</span>;</span>
<span id="cb139-31"><a href="univariate-random-variables.html#cb139-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> &amp;res;</span>
<span id="cb139-32"><a href="univariate-random-variables.html#cb139-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb139-33"><a href="univariate-random-variables.html#cb139-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-34"><a href="univariate-random-variables.html#cb139-34" aria-hidden="true" tabindex="-1"></a><span class="co">// A seed initializer using Marsaglia's congruential PRNG</span></span>
<span id="cb139-35"><a href="univariate-random-variables.html#cb139-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-36"><a href="univariate-random-variables.html#cb139-36" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span>  user_unif_init(Int32 seed_in) { </span>
<span id="cb139-37"><a href="univariate-random-variables.html#cb139-37" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">0</span>] = seed_in;</span>
<span id="cb139-38"><a href="univariate-random-variables.html#cb139-38" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">1</span>] = <span class="dv">69069</span> * z[<span class="dv">0</span>] + <span class="dv">1</span>;</span>
<span id="cb139-39"><a href="univariate-random-variables.html#cb139-39" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">2</span>] = <span class="dv">69069</span> * z[<span class="dv">1</span>] + <span class="dv">1</span>;</span>
<span id="cb139-40"><a href="univariate-random-variables.html#cb139-40" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">3</span>] = <span class="dv">69069</span> * z[<span class="dv">2</span>] + <span class="dv">1</span>;</span>
<span id="cb139-41"><a href="univariate-random-variables.html#cb139-41" aria-hidden="true" tabindex="-1"></a>  z[<span class="dv">4</span>] = <span class="dv">69069</span> * z[<span class="dv">3</span>] + <span class="dv">1</span>;</span>
<span id="cb139-42"><a href="univariate-random-variables.html#cb139-42" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb139-43"><a href="univariate-random-variables.html#cb139-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-44"><a href="univariate-random-variables.html#cb139-44" aria-hidden="true" tabindex="-1"></a><span class="co">// Two functions to make '.Random.seed' in R reflect the state vector</span></span>
<span id="cb139-45"><a href="univariate-random-variables.html#cb139-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-46"><a href="univariate-random-variables.html#cb139-46" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> * user_unif_nseed() { <span class="cf">return</span> &amp;nseed; }</span>
<span id="cb139-47"><a href="univariate-random-variables.html#cb139-47" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> * user_unif_seedloc() { <span class="cf">return</span> (<span class="dt">int</span> *) &amp;z; }</span>
<span id="cb139-48"><a href="univariate-random-variables.html#cb139-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-49"><a href="univariate-random-variables.html#cb139-49" aria-hidden="true" tabindex="-1"></a><span class="co">// Wrapper to make 'user_unif_rand' callable from R</span></span>
<span id="cb139-50"><a href="univariate-random-variables.html#cb139-50" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> xor_runif() {</span>
<span id="cb139-51"><a href="univariate-random-variables.html#cb139-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> *user_unif_rand();</span>
<span id="cb139-52"><a href="univariate-random-variables.html#cb139-52" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb139-53"><a href="univariate-random-variables.html#cb139-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-54"><a href="univariate-random-variables.html#cb139-54" aria-hidden="true" tabindex="-1"></a><span class="co">// This module will export two functions to be directly available from R.</span></span>
<span id="cb139-55"><a href="univariate-random-variables.html#cb139-55" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: if nothing is exported, `sourceCpp` will not load the shared </span></span>
<span id="cb139-56"><a href="univariate-random-variables.html#cb139-56" aria-hidden="true" tabindex="-1"></a><span class="co">// object file generated by the compilation of the code, and </span></span>
<span id="cb139-57"><a href="univariate-random-variables.html#cb139-57" aria-hidden="true" tabindex="-1"></a><span class="co">// 'user_unif_rand' will not become available to the internals of R. </span></span>
<span id="cb139-58"><a href="univariate-random-variables.html#cb139-58" aria-hidden="true" tabindex="-1"></a>RCPP_MODULE(xorwow) {</span>
<span id="cb139-59"><a href="univariate-random-variables.html#cb139-59" aria-hidden="true" tabindex="-1"></a>  Rcpp::function(<span class="st">"xor_set.seed"</span>, &amp;user_unif_init, <span class="st">"Seeds Marsaglia's xorwow"</span>);</span>
<span id="cb139-60"><a href="univariate-random-variables.html#cb139-60" aria-hidden="true" tabindex="-1"></a>  Rcpp::function(<span class="st">"xor_runif"</span>, &amp;xor_runif, <span class="st">"A uniform from Marsaglia's xorwow"</span>);</span>
<span id="cb139-61"><a href="univariate-random-variables.html#cb139-61" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We first test the direct interface to the xorwow algorithm.</p>
<div class="sourceCode" id="cb140"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">xor_set.seed</span><span class="op">(</span><span class="fl">3573076633</span><span class="op">)</span>
<span class="fu">xor_runif</span><span class="op">(</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.9090892</code></pre>
<p>Then we set R’s pseudorandom number generator to be our user supplied
generator.</p>
<div class="sourceCode" id="cb142"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">default_prng</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Random.html">RNGkind</a></span><span class="op">(</span><span class="st">"user"</span><span class="op">)</span></code></pre></div>
<p>All R’s standard random number generators will after the call <code><a href="https://rdrr.io/r/base/Random.html">RNGkind("user")</a></code>
rely on the user provided generator, in this case the xorwow generator.
Note that R does an “initial scrambling” of the argument given to <code>set.seed</code>
before it is passed on to our user defined initializer. This
scrambling turns 24102019 used below into 3573076633 used above.</p>
<div class="sourceCode" id="cb143"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">24102019</span><span class="op">)</span>
<span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>  <span class="co">## The state vector as seeded </span></code></pre></div>
<pre><code>## [1] -721890663    9136518 -310030769 1191753796  194708085</code></pre>
<div class="sourceCode" id="cb145"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>          <span class="co">## As above since same unscrambled seed is used</span></code></pre></div>
<pre><code>## [1] 0.9090892</code></pre>
<div class="sourceCode" id="cb147"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">.Random.seed</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>  <span class="co">## The state vector after one update</span></code></pre></div>
<pre><code>## [1] -721528226  331069150    9136518 -310030769 1191753796</code></pre>
<p>The code above shows the state vector of the xorwow algorithm when seeded
by the <code>user_unif_init</code> function, and it also shows the
update to the state vector after a single iteration of the xorwow algorithm.</p>
<p>Though the xorwow algorithm is fast and simple, a benchmark study (not shown)
reveals that using xorwow instead of the Mersenne Twister doesn’t impact the
run time in a notable way when using e.g. <code>runif</code>. The generator is simply
not the bottleneck. As the implementation
of xorwow above is experimental and has not been thoroughly tested, we will
not rely on it and quickly reset the random number generator to its default value.</p>
<div class="sourceCode" id="cb149"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Resetting the generator to the default</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">RNGkind</a></span><span class="op">(</span><span class="va">default_prng</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></code></pre></div>
</div>
<div id="rng-packages" class="section level3" number="4.1.2">
<h3>
<span class="header-section-number">4.1.2</span> Pseudorandom number packages<a class="anchor" aria-label="anchor" href="#rng-packages"><i class="fas fa-link"></i></a>
</h3>
<p>To benefit from the recent developments in pseudorandom number generators
we can turn to R packages such as the <a href="https://CRAN.R-project.org/package=dqrng">dqrng</a>
package. It implements pcg64 from the <a href="http://www.pcg-random.org">PCG family</a> of
generators as well as <a href="http://prng.di.unimi.it">Xoroshiro128+ and Xoshiro256+</a>
that are shift-register algorithms. Xoroshiro128+ is the default and other
generators can be chosen using <code>dqRNGkind</code>. The usage of generators from dqrng
is similar to the usage of base R generators.</p>
<div class="sourceCode" id="cb150"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://daqana.github.io/dqrng/">dqrng</a></span><span class="op">)</span>
<span class="fu"><a href="https://daqana.github.io/dqrng/reference/dqrng-functions.html">dqset.seed</a></span><span class="op">(</span><span class="fl">24102019</span><span class="op">)</span>
<span class="fu"><a href="https://daqana.github.io/dqrng/reference/dqrng-functions.html">dqrunif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.6172152</code></pre>
<p>Using the generators from dqrng does not interfere with the base R generators
as the state vectors are completely separated.</p>
<p>In addition to uniform pseudorandom variables generated by <code>dqrunif</code> the
dqrng package can generate exponential (<code>dqrexp</code>) and Gaussian (<code>dqrnorm</code>)
random variables as well as uniform discrete distributions (<code>dqsample</code> and
<code>dqsample.int</code>). All based on the fast pseudorandom integer generators that
the package includes. In addition, the package has a C++ interface that makes it
possible to use its generators in compiled code as well.</p>
<div class="sourceCode" id="cb152"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html">microbenchmark</a></span><span class="op">(</span>
  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1e6</span><span class="op">)</span>,
  <span class="fu"><a href="https://daqana.github.io/dqrng/reference/dqrng-functions.html">dqrunif</a></span><span class="op">(</span><span class="fl">1e6</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<pre><code>## Unit: milliseconds
##            expr  min   lq mean median   uq   max neval
##    runif(1e+06) 25.7 28.3 32.5     29 30.8 151.9   100
##  dqrunif(1e+06)  4.3  4.9  6.6      7  7.4   9.8   100</code></pre>
<p>As the benchmark above shows, <code>dqrunif</code> is about six times faster than
<code>runif</code> when generating one million variables. The other generators provided
by the dqrng package show similar improvements over the base R generators.</p>
</div>
</div>
<div id="transformation-techniques" class="section level2" number="4.2">
<h2>
<span class="header-section-number">4.2</span> Transformation techniques<a class="anchor" aria-label="anchor" href="#transformation-techniques"><i class="fas fa-link"></i></a>
</h2>
<p>If <span class="math inline">\(T : \mathcal{Z} \to \mathbb{R}\)</span> is a map and <span class="math inline">\(Z \in \mathcal{Z}\)</span> is a random
variable we can simulate, then we can simulate <span class="math inline">\(X = T(Z).\)</span></p>

<div class="theorem">
<p><span id="thm:inverse-distribution-function" class="theorem"><strong>Theorem 4.1  </strong></span>If <span class="math inline">\(F^{\leftarrow} : (0,1) \mapsto \mathbb{R}\)</span>
is the (generalized) inverse of a distribution function and <span class="math inline">\(U\)</span> is uniformly distributed
on <span class="math inline">\((0, 1)\)</span> then the distribution of
<span class="math display">\[F^{\leftarrow}(U)\]</span>
has distribution function <span class="math inline">\(F\)</span>.</p>
</div>
<p>The proof of Theorem <a href="univariate-random-variables.html#thm:inverse-distribution-function">4.1</a> can be found in many
textbooks and will be skipped. It is easiest to use this theorem if
we have an analytic formula for the inverse distribution function. But even
in cases where we don’t it might be useful for simulation anyway if we have
a very accurate approximation that is fast to evaluate.</p>
<p>The call <code><a href="https://rdrr.io/r/base/Random.html">RNGkind()</a></code> in the previous section revealed that the <a href="https://github.com/wch/r-source/blob/af7f52f70101960861e5d995d3a4bec010bc89e6/src/nmath/snorm.c#L265">default in R</a> for generating samples from <span class="math inline">\(\mathcal{N}(0,1)\)</span> is inversion. That is,
Theorem <a href="univariate-random-variables.html#thm:inverse-distribution-function">4.1</a> is used to transform
uniform random variables with the inverse distribution function <span class="math inline">\(\Phi^{-1}\)</span>.
This function is, however, non-standard, and R implements a
<a href="https://github.com/wch/r-source/blob/af7f52f70101960861e5d995d3a4bec010bc89e6/src/nmath/qnorm.c#L52">technical approximation</a> of <span class="math inline">\(\Phi^{-1}\)</span> via rational functions.</p>
<div id="sampling-from-a-t-distribution" class="section level3" number="4.2.1">
<h3>
<span class="header-section-number">4.2.1</span> Sampling from a <span class="math inline">\(t\)</span>-distribution<a class="anchor" aria-label="anchor" href="#sampling-from-a-t-distribution"><i class="fas fa-link"></i></a>
</h3>
<p>Let <span class="math inline">\(Z = (Y, W) \in \mathbb{R} \times (0, \infty)\)</span> with <span class="math inline">\(Z \sim \mathcal{N}(0, 1)\)</span> and
<span class="math inline">\(W \sim \chi^2_k\)</span> independent.</p>
<p>Define <span class="math inline">\(T : \mathbb{R} \times (0, \infty) \to \mathbb{R}\)</span> by
<span class="math display">\[T(z,w) = \frac{z}{\sqrt{w/k}},\]</span>
then
<span class="math display">\[X = T(Z, W) = \frac{Z}{\sqrt{W/k}} \sim t_k.\]</span></p>
<p>This is how R simulates from a <span class="math inline">\(t\)</span>-distribution with <span class="math inline">\(W\)</span> generated from a
gamma distribution with shape parameter <span class="math inline">\(k / 2\)</span> and scale parameter <span class="math inline">\(2\)</span>.</p>
</div>
</div>
<div id="reject-samp" class="section level2" number="4.3">
<h2>
<span class="header-section-number">4.3</span> Rejection sampling<a class="anchor" aria-label="anchor" href="#reject-samp"><i class="fas fa-link"></i></a>
</h2>
<p>This section deals with a general algorithm for simulating variables
from a distribution with density <span class="math inline">\(f\)</span>. We call <span class="math inline">\(f\)</span> the target density
and the corresponding distribution is called the target distribution.
The idea is to simulate <em>proposals</em> from a different distribution
with density <span class="math inline">\(g\)</span> (the proposal distribution) and then according to
a criterion decide to accept or reject the proposals. It is assumed
throughout that the proposal density <span class="math inline">\(g\)</span> is a density fulfilling that</p>
<p><span class="math display" id="eq:gfnull">\[\begin{equation}
g(x) = 0 \Rightarrow f(x) = 0.
\tag{4.1}
\end{equation}\]</span></p>
<p>Let <span class="math inline">\(Y_1, Y_2, \ldots\)</span> be i.i.d. with density <span class="math inline">\(g\)</span> on <span class="math inline">\(\mathbb{R}\)</span> and <span class="math inline">\(U_1, U_2, \ldots\)</span>
be i.i.d. uniformly distributed on <span class="math inline">\((0,1)\)</span> and independent of the <span class="math inline">\(Y_i\)</span>-s. Define
<span class="math display">\[T(\mathbf{Y}, \mathbf{U}) = Y_{\sigma}\]</span>
with
<span class="math display">\[\sigma = \inf\{n \geq 1 \mid U_n \leq \alpha f(Y_n) / g(Y_n)\},\]</span>
for <span class="math inline">\(\alpha \in (0, 1]\)</span> and <span class="math inline">\(f\)</span> a density. Rejection sampling then consists
of simulating independent pairs <span class="math inline">\((Y_n, U_n)\)</span> as long as we <em>reject</em> the
proposals <span class="math inline">\(Y_n\)</span> sampled from <span class="math inline">\(g\)</span>,
that is, as long as
<span class="math display">\[U_n &gt; \alpha f(Y_n) / g(Y_n).\]</span>
The first time we <em>accept</em> a proposal is <span class="math inline">\(\sigma\)</span>, and then we stop the
sampling and return the proposal <span class="math inline">\(Y_{\sigma}\)</span>. The result is, indeed,
a sample from the distribution with density <span class="math inline">\(f\)</span> as the following theorem states.</p>

<div class="theorem">
<p><span id="thm:reject" class="theorem"><strong>Theorem 4.2  </strong></span>If <span class="math inline">\(\alpha f(y) \leq g(y)\)</span> for all <span class="math inline">\(y \in \mathbb{R}\)</span> and <span class="math inline">\(\alpha &gt; 0\)</span>
then the distribution of <span class="math inline">\(Y_{\sigma}\)</span> has density <span class="math inline">\(f\)</span>.</p>
</div>

<div class="proof">
<p> <span class="proof"><em>Proof. </em></span> Note that <span class="math inline">\(g\)</span> automatically fulfills <a href="univariate-random-variables.html#eq:gfnull">(4.1)</a>. The formal proof decomposes
the event <span class="math inline">\((Y_{\sigma} \leq y)\)</span> according to the value of <span class="math inline">\(\sigma\)</span> as follows</p>
<p><span class="math display">\[\begin{align}
P(Y_{\sigma} \leq y) &amp; = \sum_{n = 1}^{\infty} P(Y_{n} \leq y, \ \sigma = n) \\
&amp; = \sum_{n = 1}^{\infty} P(Y_{n} \leq y, \ U_n \leq \alpha f(Y_n) / g(Y_n)) P(\sigma &gt; n - 1) \\
&amp; = P(Y_{1} \leq y, \ U_1 \leq \alpha f(Y_1) / g(Y_1)) \sum_{n = 1}^{\infty} P(\sigma &gt; n - 1).
\end{align}\]</span></p>
<p>By independence of the pairs <span class="math inline">\((Y_n, U_n)\)</span> we find that
<span class="math display">\[P(\sigma &gt; n - 1) = p^{(n-1)}\]</span>
where <span class="math inline">\(p = P(U_1 &gt; \alpha f(Y_1) / g(Y_1))\)</span>, and
<span class="math display">\[\sum_{n = 1}^{\infty} P(\sigma &gt; n - 1) = \sum_{n = 1}^{\infty} p^{(n-1)} = \frac{1}{1 - p}.\]</span></p>
<p>We further find using Tonelli’s theorem that</p>
<p><span class="math display">\[\begin{align}
P(Y_{1} \leq y, \ U_1 \leq \alpha f(Y_1) / g(Y_1)) &amp; = \int_{-\infty}^y \alpha \frac{f(z)}{g(z)} g(z) \mathrm{d}z \\
&amp; = \alpha \int_{-\infty}^y f(z) \mathrm{d} z.
\end{align}\]</span></p>
<p>It also follows from this, by taking <span class="math inline">\(y = \infty\)</span>, that <span class="math inline">\(1 - p = \alpha\)</span>,
and we conclude that
<span class="math display">\[P(Y_{\sigma} \leq y) = \int_{-\infty}^y f(z) \mathrm{d} z,\]</span>
and the density for the distribution of <span class="math inline">\(Y_{\sigma}\)</span> is, indeed, <span class="math inline">\(f\)</span>.</p>
</div>
<p>Note that if <span class="math inline">\(\alpha f \leq g\)</span> for <em>densities</em> <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span>, then
<span class="math display">\[\alpha = \int \alpha f(x) \mathrm{d}x \leq \int g(x) \mathrm{d}x = 1,\]</span>
whence it follows automatically that <span class="math inline">\(\alpha \leq 1\)</span> whenever <span class="math inline">\(\alpha f\)</span> is
dominated by <span class="math inline">\(g\)</span>. The function <span class="math inline">\(g/\alpha\)</span> is called the <em>envelope</em> of <span class="math inline">\(f\)</span>.
The tighter the envelope, the smaller is the probability of rejecting
a sample from <span class="math inline">\(g\)</span>, and this is quantified explicitly by <span class="math inline">\(\alpha\)</span> as <span class="math inline">\(1 - \alpha\)</span>
is the rejection probability. Thus <span class="math inline">\(\alpha\)</span> should preferably be as close to
one as possible.</p>
<p>If <span class="math inline">\(f(y) = c q(y)\)</span> and <span class="math inline">\(g(y) = d p(y)\)</span> for (unknown) normalizing constants
<span class="math inline">\(c, d &gt; 0\)</span> and <span class="math inline">\(\alpha' q \leq p\)</span> for <span class="math inline">\(\alpha' &gt; 0\)</span> then
<span class="math display">\[\underbrace{\left(\frac{\alpha' d}{c}\right)}_{= \alpha} \ f \leq g.\]</span>
The constant <span class="math inline">\(\alpha'\)</span> may be larger than 1, but from the argument above
we know that <span class="math inline">\(\alpha \leq 1\)</span>, and Theorem <a href="univariate-random-variables.html#thm:reject">4.2</a> gives that
<span class="math inline">\(Y_{\sigma}\)</span> has distribution with density <span class="math inline">\(f\)</span>. It appears that we need to
compute the normalizing constants to implement rejection sampling. However,
observe that
<span class="math display">\[u \leq \frac{\alpha f(y)}{g(y)} \Leftrightarrow u \leq \frac{\alpha' q(y)}{p(y)},\]</span>
whence rejection sampling can actually be implemented with knowledge
of the unnormalized densities and <span class="math inline">\(\alpha'\)</span> only and without computing <span class="math inline">\(c\)</span> or <span class="math inline">\(d\)</span>.
This is one great advantage of rejection sampling. We should
note, though, that when we don’t know the normalizing constants, <span class="math inline">\(\alpha'\)</span> does not tell
us anything about how tight the envelope is, and thus how small the rejection
probability is.</p>
<p>Given two functions <span class="math inline">\(q\)</span> and <span class="math inline">\(p\)</span>, how do we then find <span class="math inline">\(\alpha'\)</span> so that
<span class="math inline">\(\alpha' q \leq p\)</span>? Consider the function
<span class="math display">\[y \mapsto \frac{p(y)}{q(y)}\]</span>
for <span class="math inline">\(q(y) &gt; 0\)</span>. If this function is lower bounded by a value strictly larger than
zero, we can take
<span class="math display">\[\alpha' = \inf_{y: q(y) &gt; 0} \frac{p(y)}{q(y)} &gt; 0.\]</span>
We can in practice often find this value by minimizing <span class="math inline">\(p(y)/q(y)\)</span>. If
the minimum is zero, there is no <span class="math inline">\(\alpha'\)</span>, and <span class="math inline">\(p\)</span> cannot be
used to construct an envelope. If the minimum is strictly positive
it is the best possible choice of <span class="math inline">\(\alpha'\)</span>.</p>
<div id="vMsim" class="section level3" number="4.3.1">
<h3>
<span class="header-section-number">4.3.1</span> von Mises distribution<a class="anchor" aria-label="anchor" href="#vMsim"><i class="fas fa-link"></i></a>
</h3>
<p>Recall the <a href="intro.html#vM">von Mises distribution</a> from Section <a href="intro.html#vM">1.2.1</a>. It is a
distribution on <span class="math inline">\((-\pi, \pi]\)</span> with density
<span class="math display">\[f(x) \propto e^{\kappa \cos(x - \mu)}\]</span>
for parameters <span class="math inline">\(\kappa &gt; 0\)</span> and <span class="math inline">\(\mu \in (-\pi, \pi]\)</span>. Clearly, <span class="math inline">\(\mu\)</span> is a
location parameter, and we fix <span class="math inline">\(\mu = 0\)</span> in the following. Simulating random variables
with <span class="math inline">\(\mu \neq 0\)</span> can be achieved by (wrapped) translation of variables
with <span class="math inline">\(\mu = 0\)</span>.</p>
<p>Thus the target density is <span class="math inline">\(f(x) \propto e^{\kappa \cos(x)}\)</span>. In this section
we will use the uniform distribution on <span class="math inline">\((-\pi, \pi)\)</span> as proposal distribution.
It has constant density <span class="math inline">\(g(x) = (2\pi)^{-1}\)</span>, but all we need is, in fact, that
<span class="math inline">\(g(x) \propto 1\)</span>. Since <span class="math inline">\(x \mapsto 1 / \exp(\kappa \cos(x)) = \exp(-\kappa \cos(x))\)</span> attains its
minimum <span class="math inline">\(\exp(-\kappa)\)</span> for <span class="math inline">\(x = 0\)</span>, we find that
<span class="math display">\[\alpha' e^{\kappa \cos(x)} = e^{\kappa(\cos(x) - 1)} \leq 1,\]</span>
with <span class="math inline">\(\alpha' = \exp(-\kappa)\)</span>. The rejection test of the
proposal <span class="math inline">\(Y \sim g\)</span> can therefore be carried out
by testing if a uniformly distributed random variable <span class="math inline">\(U\)</span> on <span class="math inline">\((0,1)\)</span>
satisfies
<span class="math display">\[U &gt; e^{\kappa(\cos(Y) - 1)}.\]</span></p>
<div class="sourceCode" id="cb154"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">vMsim_slow</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">kappa</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">reject</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span>
    <span class="kw">while</span><span class="op">(</span><span class="va">reject</span><span class="op">)</span> <span class="op">{</span>
      <span class="va">y0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span> <span class="va">pi</span>, <span class="va">pi</span><span class="op">)</span>
      <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>
      <span class="va">reject</span> <span class="op">&lt;-</span> <span class="va">u</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">kappa</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">y0</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
    <span class="op">}</span>
    <span class="va">y</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">y0</span>
  <span class="op">}</span>
  <span class="va">y</span>
<span class="op">}</span></code></pre></div>
<div class="sourceCode" id="cb155"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">f</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">k</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">k</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="fl">2</span> <span class="op">*</span> <span class="va">pi</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Bessel.html">besselI</a></span><span class="op">(</span><span class="va">k</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="fu">vMsim_slow</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">0.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">x</span>, breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, length.out <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, prob <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/curve.html">curve</a></span><span class="op">(</span><span class="fu">f</span><span class="op">(</span><span class="va">x</span>, <span class="fl">0.5</span><span class="op">)</span>, <span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, col <span class="op">=</span> <span class="st">"blue"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="fu">vMsim_slow</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">2</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">x</span>, breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, length.out <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, prob <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/curve.html">curve</a></span><span class="op">(</span><span class="fu">f</span><span class="op">(</span><span class="va">x</span>, <span class="fl">2</span><span class="op">)</span>, <span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, col <span class="op">=</span> <span class="st">"blue"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vMsim"></span>
<img src="CSwR_files/figure-html/vMsim-1.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right). The true densities (blue) are added to the plots." width="49%"><img src="CSwR_files/figure-html/vMsim-2.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right). The true densities (blue) are added to the plots." width="49%"><p class="caption">
Figure 4.1: Histograms of 100,000 simulated data points from von Mises distributions with parameters <span class="math inline">\(\kappa = 0.5\)</span> (left) and <span class="math inline">\(\kappa = 2\)</span> (right). The true densities (blue) are added to the plots.
</p>
</div>

<p>Figure <a href="univariate-random-variables.html#fig:vMsim">4.1</a> confirms that the implementation simulates
from the von Mises distribution.</p>
<div class="sourceCode" id="cb156"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/system.time.html">system.time</a></span><span class="op">(</span><span class="fu">vMsim_slow</span><span class="op">(</span><span class="fl">100000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##    user  system elapsed 
##   2.507   0.158   2.693</code></pre>
<p>Though the implementation can easily simulate 100,000 variables in a couple of
seconds, it might still be possible to improve it. To investigate what most
of the run time is spent on we use the line profiling tool as implemented in
the profvis package.</p>
<div class="sourceCode" id="cb158"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rstudio.github.io/profvis/">profvis</a></span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/pkg/profvis/man/profvis.html">profvis</a></span><span class="op">(</span><span class="fu">vMsim_slow</span><span class="op">(</span><span class="fl">10000</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="figures/vMsim-profile.png" width="90%" style="display: block; margin: auto;"></div>
<p>The <a href="https://cswr.nrhstat.org/figures/vMsim-profile.html">profiling result</a> shows that almost all the time
is spent on simulating uniformly distributed random variables. It is, perhaps,
expected that this should take some time, but that it takes so much more time
than computing the ratio, say, used for the rejection test is a bit surprising.
What might be even more surprising is the large amount of memory allocation
and deallocation associated with the simulation of the variables.</p>
<p>The culprit is <code>runif</code> that has some overhead associated with each call.
The function performs much better if called once to return a vector than
if called repeatedly as above to return just single numbers. We could
rewrite the rejection sampler to make better use of <code>runif</code>, but it would
make the code a bit more complicated because we don’t know upfront
how many uniform variables we need. This will introduce some bookkeeping
that it is possible to abstract away from the implementation of any
rejection sampler. Therefore we implement a generic
wrapper of the random number generator that will cache a suitable amount
of random variables. This function will take care of some bookkeeping
and variables can then be extracted as needed. This also nicely
illustrates the use of a <a href="https://adv-r.hadley.nz/function-factories.html">function factory</a>.</p>
<div class="sourceCode" id="cb159"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">rng_stream</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">m</span>, <span class="va">rng</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">args</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span>
  <span class="va">cache</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span><span class="op">(</span><span class="va">rng</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">m</span>, <span class="va">args</span><span class="op">)</span><span class="op">)</span>
  <span class="va">j</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">fact</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">next_rn</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">r</span> <span class="op">=</span> <span class="va">m</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">j</span> <span class="op">&lt;&lt;-</span> <span class="va">j</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">j</span> <span class="op">&gt;</span> <span class="va">m</span><span class="op">)</span> <span class="op">{</span>
      <span class="kw">if</span><span class="op">(</span><span class="va">fact</span> <span class="op">==</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> <span class="va">r</span> <span class="op">&lt;</span> <span class="va">m</span><span class="op">)</span> <span class="va">fact</span> <span class="op">&lt;&lt;-</span> <span class="va">m</span> <span class="op">/</span> <span class="op">(</span><span class="va">m</span> <span class="op">-</span> <span class="va">r</span><span class="op">)</span>
      <span class="va">m</span> <span class="op">&lt;&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="va">fact</span> <span class="op">*</span> <span class="op">(</span><span class="va">r</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
      <span class="va">cache</span> <span class="op">&lt;&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span><span class="op">(</span><span class="va">rng</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">m</span>, <span class="va">args</span><span class="op">)</span><span class="op">)</span>
      <span class="va">j</span> <span class="op">&lt;&lt;-</span> <span class="fl">1</span>
    <span class="op">}</span>
    <span class="va">cache</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> 
  <span class="op">}</span>
  <span class="va">next_rn</span>
<span class="op">}</span></code></pre></div>
<p>The implementation above is a function that returns a function. The returned
function, <code>next_rn</code> comes with its own environment, where it stores the
cached variables and extracts and returns one variable whenever called.
It generates a new vector of random variables
whenever it “runs out.” The first time it does so, the function estimates a
factor of how many variables is needed in total based on the argument <code>r</code>, and
then it generates the estimated number of variables needed. This may be
repeated a couple of times.</p>
<p>We can then reimplement <code>vMsim</code> using <code>rng_stream</code>. For later usage we add the
possibility of printing out some tracing information.</p>
<div class="sourceCode" id="cb160"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">vMsim</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">kappa</span>, <span class="va">trace</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">count</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="va">y0</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span>, <span class="op">-</span> <span class="va">pi</span>, <span class="va">pi</span><span class="op">)</span>
  <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span><span class="op">)</span>
  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">reject</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span>
    <span class="kw">while</span><span class="op">(</span><span class="va">reject</span><span class="op">)</span> <span class="op">{</span>
      <span class="va">count</span> <span class="op">&lt;-</span> <span class="va">count</span> <span class="op">+</span> <span class="fl">1</span>
      <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu">y0</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span>
      <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">kappa</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
    <span class="op">}</span>
    <span class="va">y</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">z</span>
  <span class="op">}</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">trace</span><span class="op">)</span>
    <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"kappa ="</span>, <span class="va">kappa</span>, <span class="st">":"</span>, <span class="op">(</span><span class="va">count</span> <span class="op">-</span> <span class="va">n</span><span class="op">)</span><span class="op">/</span> <span class="va">count</span>, <span class="st">"\n"</span><span class="op">)</span>  <span class="co">## Rejection frequency</span>
  <span class="va">y</span>
<span class="op">}</span></code></pre></div>
<p>We should, of course, remember to test that the new implementation still
generates variables from the von Mises distribution.</p>
<div class="sourceCode" id="cb161"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu">vMsim</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">0.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">x</span>, breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, length.out <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, prob <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/curve.html">curve</a></span><span class="op">(</span><span class="fu">f</span><span class="op">(</span><span class="va">x</span>, <span class="fl">0.5</span><span class="op">)</span>, <span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, col <span class="op">=</span> <span class="st">"blue"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="fu">vMsim</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">2</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">x</span>, breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, length.out <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, prob <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/curve.html">curve</a></span><span class="op">(</span><span class="fu">f</span><span class="op">(</span><span class="va">x</span>, <span class="fl">2</span><span class="op">)</span>, <span class="op">-</span><span class="va">pi</span>, <span class="va">pi</span>, col <span class="op">=</span> <span class="st">"blue"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vMsim2"></span>
<img src="CSwR_files/figure-html/vMsim2-1.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right), simulated using vectorized generation of random variables." width="49%"><img src="CSwR_files/figure-html/vMsim2-2.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right), simulated using vectorized generation of random variables." width="49%"><p class="caption">
Figure 4.2: Histograms of 100,000 simulated data points from von Mises distributions with parameters <span class="math inline">\(\kappa = 0.5\)</span> (left) and <span class="math inline">\(\kappa = 2\)</span> (right), simulated using vectorized generation of random variables.
</p>
</div>

<p>Then we can compare the run time of this new implementation to the
run time of the first implementation.</p>
<div class="sourceCode" id="cb162"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/system.time.html">system.time</a></span><span class="op">(</span><span class="fu">vMsim</span><span class="op">(</span><span class="fl">100000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##    user  system elapsed 
##   1.076   0.718   2.052</code></pre>
<p>As we see from the time estimate above, using a vectorized call of <code>runif</code>
reduces the run time by a factor 4-5. It is possible to get a further factor 2-3
run time improvement (not shown) by implementing the computations done by
<code>rng_stream</code> directly inside <code>vMsim</code>. However, we prioritize here to have
modular code so that we can reuse <code>rng_stream</code> for other rejection samplers without
repeating code. A pure R implementation based on a loop will never be able to
compete with a C++ implementation anyway when the accept-reject step is such a
simple computation.</p>
<p>In fact, to write a pure R function that is run time efficient, we need to
turn the entire rejection sampler into a vectorized computation. That is,
it is not just the generation of random numbers that need to be vectorized.
There is no way around some form of loop as we don’t known upfront how many
rejections there will be. We can, however, benefit from the ideas in <code>rng_stream</code>
on how to estimate the fraction of acceptances from a first round, which can be
used for subsequent simulations. This is done in the following fully
vectorized R implementation.</p>
<div class="sourceCode" id="cb164"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">vMsim_vec</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">kappa</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">fact</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">j</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">l</span> <span class="op">&lt;-</span> <span class="fl">0</span>  <span class="co">## The number of accepted samples</span>
  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="op">)</span>
  <span class="kw">while</span><span class="op">(</span><span class="va">l</span> <span class="op">&lt;</span> <span class="va">n</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">m</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="va">fact</span> <span class="op">*</span> <span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">l</span><span class="op">)</span><span class="op">)</span>  <span class="co">## equals n the first time</span>
    <span class="va">y0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="va">m</span>, <span class="op">-</span> <span class="va">pi</span>, <span class="va">pi</span><span class="op">)</span>
    <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span>
    <span class="va">accept</span> <span class="op">&lt;-</span> <span class="va">u</span> <span class="op">&lt;=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">kappa</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">y0</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
    <span class="va">l</span> <span class="op">&lt;-</span> <span class="va">l</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">accept</span><span class="op">)</span>
    <span class="va">y</span><span class="op">[[</span><span class="va">j</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">y0</span><span class="op">[</span><span class="va">accept</span><span class="op">]</span>
    <span class="va">j</span> <span class="op">&lt;-</span> <span class="va">j</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">fact</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span> <span class="va">fact</span> <span class="op">&lt;-</span> <span class="va">n</span> <span class="op">/</span> <span class="va">l</span>
  <span class="op">}</span>
  <span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">]</span>
<span class="op">}</span></code></pre></div>
<p>The implementation above incrementally grows a list, whose entries contain
vectors of accepted samples. It is usually not advisable to dynamically
grow objects (vectors or list), as this will lead to a lot of memory
allocation, copying and deallocation. Thus it is better to initialize a vector
of the correct size upfront. In this particular case the list will only contain
few entries, and it is inconsequential that it is grown dynamically.</p>
<p>Finally, a C++ implementation via Rcpp is given below where the random variables are
then again generated one at a time via the C-interface to R’s random number
generators. There is no (substantial) overhead of doing so in C++.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="univariate-random-variables.html#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span></span>
<span id="cb165-2"><a href="univariate-random-variables.html#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</span>
<span id="cb165-3"><a href="univariate-random-variables.html#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb165-4"><a href="univariate-random-variables.html#cb165-4" aria-hidden="true" tabindex="-1"></a>NumericVector vMsim_cpp(<span class="dt">int</span> n, <span class="dt">double</span> kappa) {</span>
<span id="cb165-5"><a href="univariate-random-variables.html#cb165-5" aria-hidden="true" tabindex="-1"></a>  NumericVector y(n);</span>
<span id="cb165-6"><a href="univariate-random-variables.html#cb165-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> y0;</span>
<span id="cb165-7"><a href="univariate-random-variables.html#cb165-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> reject;</span>
<span id="cb165-8"><a href="univariate-random-variables.html#cb165-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {</span>
<span id="cb165-9"><a href="univariate-random-variables.html#cb165-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span> {</span>
<span id="cb165-10"><a href="univariate-random-variables.html#cb165-10" aria-hidden="true" tabindex="-1"></a>      y0 = R::runif(- M_PI, M_PI);</span>
<span id="cb165-11"><a href="univariate-random-variables.html#cb165-11" aria-hidden="true" tabindex="-1"></a>      reject = R::runif(<span class="dv">0</span>, <span class="dv">1</span>) &gt; exp(kappa * (cos(y0) - <span class="dv">1</span>));</span>
<span id="cb165-12"><a href="univariate-random-variables.html#cb165-12" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">while</span>(reject);</span>
<span id="cb165-13"><a href="univariate-random-variables.html#cb165-13" aria-hidden="true" tabindex="-1"></a>    y[i] = y0;</span>
<span id="cb165-14"><a href="univariate-random-variables.html#cb165-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb165-15"><a href="univariate-random-variables.html#cb165-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> y;</span>
<span id="cb165-16"><a href="univariate-random-variables.html#cb165-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vMsim3"></span>
<img src="CSwR_files/figure-html/vMsim3-1.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right), simulated using the Rcpp implementation (top) and the fully vectorized R implementation (bottom)." width="49%"><img src="CSwR_files/figure-html/vMsim3-2.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right), simulated using the Rcpp implementation (top) and the fully vectorized R implementation (bottom)." width="49%"><img src="CSwR_files/figure-html/vMsim3-3.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right), simulated using the Rcpp implementation (top) and the fully vectorized R implementation (bottom)." width="49%"><img src="CSwR_files/figure-html/vMsim3-4.png" alt="Histograms of 100,000 simulated data points from von Mises distributions with parameters \(\kappa = 0.5\) (left) and \(\kappa = 2\) (right), simulated using the Rcpp implementation (top) and the fully vectorized R implementation (bottom)." width="49%"><p class="caption">
Figure 4.3: Histograms of 100,000 simulated data points from von Mises distributions with parameters <span class="math inline">\(\kappa = 0.5\)</span> (left) and <span class="math inline">\(\kappa = 2\)</span> (right), simulated using the Rcpp implementation (top) and the fully vectorized R implementation (bottom).
</p>
</div>

<p>Figure <a href="univariate-random-variables.html#fig:vMsim3">4.3</a> shows the results from testing the C++ implementation
and the fast R implementation,
and confirms that the implementations do simulate from the von Mises distribution.
We conclude by measuring the run time of the implementations using
<code>system.time</code> and a combined microbenchmark of all four different implementations.</p>
<div class="sourceCode" id="cb166"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/system.time.html">system.time</a></span><span class="op">(</span><span class="fu">vMsim_cpp</span><span class="op">(</span><span class="fl">100000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##    user  system elapsed 
##   0.045   0.001   0.047</code></pre>
<div class="sourceCode" id="cb168"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html">microbenchmark</a></span><span class="op">(</span>
  <span class="fu">vMsim_slow</span><span class="op">(</span><span class="fl">1000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,
  <span class="fu">vMsim</span><span class="op">(</span><span class="fl">1000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,
  <span class="fu">vMsim_vec</span><span class="op">(</span><span class="fl">1000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,
  <span class="fu">vMsim_cpp</span><span class="op">(</span><span class="fl">1000</span>, kappa <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>
<span class="op">)</span></code></pre></div>
<pre><code>## Unit: microseconds
##                         expr   min    lq  mean median    uq    max neval
##  vMsim_slow(1000, kappa = 5) 17387 19161 26383  20872 23973 103838   100
##       vMsim(1000, kappa = 5)  6304  7076  8596   7897  8690  67349   100
##   vMsim_vec(1000, kappa = 5)   452   537   621    592   680   1040   100
##   vMsim_cpp(1000, kappa = 5)   298   344   388    378   407    629   100</code></pre>
<p>The C++ implementation is only a factor 1.5 faster than the fully
vectorized R implementation, while it is around a factor 15 faster
than the loop-based <code>vMsim</code> and a factor 85 or so faster than the
first implementation <code>vMsim_slow</code>. Rejection sampling is a good example
of an algorithm for which a naive loop-based R implementation
performs rather poorly in terms of run time, while a completely vectorized
implementation is competitive with an Rcpp implementation.</p>
</div>
<div id="gamma-distribution" class="section level3" number="4.3.2">
<h3>
<span class="header-section-number">4.3.2</span> Gamma distribution<a class="anchor" aria-label="anchor" href="#gamma-distribution"><i class="fas fa-link"></i></a>
</h3>
<p>It may be possible to find a suitable envelope of the density for the
gamma distribution on <span class="math inline">\((0, \infty)\)</span>, but it turns out that there is a
very efficient rejection sampler of a non-standard distribution that
can be transformed into a gamma distribution by a simple transformation.</p>
<p>Let <span class="math inline">\(t(y) = a(1 + by)^3\)</span> for <span class="math inline">\(y \in (-b^{-1}, \infty)\)</span>, then <span class="math inline">\(t(Y) \sim \Gamma(r,1)\)</span> if <span class="math inline">\(r \geq 1\)</span>
and <span class="math inline">\(Y\)</span> has density
<span class="math display">\[f(y) \propto t(y)^{r-1}t'(y) e^{-t(y)} = e^{(r-1)\log t(y) + \log t'(y) - t(y)}.\]</span></p>
<p>The proof of this follows from a simple univariate density transformation theorem,
but see also the original paper <span class="citation"><a href="references.html#ref-Marsaglia:2000" role="doc-biblioref">Marsaglia and Tsang</a> (<a href="references.html#ref-Marsaglia:2000" role="doc-biblioref">2000</a>)</span> that proposed the rejection
sampler discussed in this section. The density <span class="math inline">\(f\)</span> will be the <em>target density</em>
for a rejection sampler.</p>
<p>With
<span class="math display">\[f(y) \propto e^{(r-1)\log t(y) + \log t'(y) - t(y)},\]</span>
<span class="math inline">\(a = r - 1/3\)</span> and <span class="math inline">\(b = 1/(3 \sqrt{a})\)</span>
<span class="math display">\[f(y) \propto e^{a \log t(y)/a - t(y) + a \log a} \propto \underbrace{e^{a \log t(y)/a - t(y) + a}}_{q(y)}.\]</span></p>
<p>An analysis of <span class="math inline">\(w(y) := - y^2/2 - \log q(y)\)</span> shows that it is convex on <span class="math inline">\((-b^{-1}, \infty)\)</span>
and it attains its minimum in <span class="math inline">\(0\)</span> with <span class="math inline">\(w(0) = 0\)</span>, whence
<span class="math display">\[q(y) \leq e^{-y^2/2}.\]</span>
This gives us an envelope expressed in terms of unnormalized densities
with <span class="math inline">\(\alpha' = 1\)</span>.</p>
<p>The implementation of a rejection sampler based on this analysis is relatively
straightforward. The rejection sampler will simulate from the distribution
with density <span class="math inline">\(f\)</span> by simulating from the Gaussian distribution (the envelope).
For the rejection step we need to implement <span class="math inline">\(q\)</span>. Finally, we also need
to implement <span class="math inline">\(t\)</span> to transform the result from the rejection sampler to be
gamma distributed. The rejection sampler is otherwise implemented as for
the non-vectorized von Mises distribution. To investigate rejection probabilities below
we additionally implement the possibility of printing out some tracing
information.</p>
<div class="sourceCode" id="cb170"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## r &gt;= 1 </span>
<span class="va">tfun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">y</span>, <span class="va">a</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">b</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="fl">3</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">)</span>
  <span class="op">(</span><span class="va">y</span> <span class="op">&gt;</span> <span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="va">b</span><span class="op">)</span> <span class="op">*</span> <span class="va">a</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="va">b</span> <span class="op">*</span> <span class="va">y</span><span class="op">)</span><span class="op">^</span><span class="fl">3</span>  <span class="co">## 0 when y &lt;= -1/b</span>
<span class="op">}</span>

<span class="va">qfun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">y</span>, <span class="va">r</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">a</span> <span class="op">&lt;-</span> <span class="va">r</span> <span class="op">-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>
  <span class="va">tval</span> <span class="op">&lt;-</span> <span class="fu">tfun</span><span class="op">(</span><span class="va">y</span>, <span class="va">a</span><span class="op">)</span>
  <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">tval</span> <span class="op">/</span> <span class="va">a</span><span class="op">)</span> <span class="op">-</span> <span class="va">tval</span> <span class="op">+</span> <span class="va">a</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">gammasim</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">r</span>, <span class="va">trace</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">count</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="va">y0</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">rnorm</span><span class="op">)</span>
  <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span><span class="op">)</span>
  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">reject</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span>
    <span class="kw">while</span><span class="op">(</span><span class="va">reject</span><span class="op">)</span> <span class="op">{</span>
      <span class="va">count</span> <span class="op">&lt;-</span> <span class="va">count</span> <span class="op">+</span> <span class="fl">1</span>
      <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu">y0</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span>
      <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu">qfun</span><span class="op">(</span><span class="va">z</span>, <span class="va">r</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">z</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span>
    <span class="op">}</span>
    <span class="va">y</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">z</span>
  <span class="op">}</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">trace</span><span class="op">)</span>
    <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"r ="</span>, <span class="va">r</span>, <span class="st">":"</span>, <span class="op">(</span><span class="va">count</span> <span class="op">-</span> <span class="va">n</span><span class="op">)</span><span class="op">/</span> <span class="va">count</span>, <span class="st">"\n"</span><span class="op">)</span>  <span class="co">## Rejection frequency</span>
  <span class="fu">tfun</span><span class="op">(</span><span class="va">y</span>, <span class="va">r</span> <span class="op">-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">3</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>We test the implementation by simulating <span class="math inline">\(100,000\)</span> values
with parameters <span class="math inline">\(r = 8\)</span> as well as <span class="math inline">\(r = 1\)</span> and compare the resulting histograms
to the respective theoretical densities.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:gammaBench"></span>
<img src="CSwR_files/figure-html/gammaBench-1.png" alt="Histograms of simulated gamma distributed variables with shape parameters $r = 8$ (left) and $r = 1$ (right) with corresponding theoretical densities (blue)." width="49%"><img src="CSwR_files/figure-html/gammaBench-2.png" alt="Histograms of simulated gamma distributed variables with shape parameters $r = 8$ (left) and $r = 1$ (right) with corresponding theoretical densities (blue)." width="49%"><p class="caption">
Figure 4.4: Histograms of simulated gamma distributed variables with shape parameters <span class="math inline">\(r = 8\)</span> (left) and <span class="math inline">\(r = 1\)</span> (right) with corresponding theoretical densities (blue).
</p>
</div>
<p>Though this is only a simple and informal test, it indicates that the implementation
correctly simulates from the gamma distribution.</p>
<p>Rejection sampling can be computationally expensive if many samples are rejected.
A very tight envelope will lead to fewer rejections, while a loose envelope will
lead to many rejections. Using the tracing option as implemented we obtain
estimates of the rejection probability and thus a quantification of
how tight the envelope is.</p>
<div class="sourceCode" id="cb171"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">gammasim</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">16</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">gammasim</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">8</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">gammasim</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">4</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">gammasim</span><span class="op">(</span><span class="fl">100000</span>, <span class="fl">1</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<pre><code>## r = 16 : 0.00161738 
## r = 8 : 0.003745915 
## r = 4 : 0.007966033 
## r = 1 : 0.04789108</code></pre>
<p>We observe that the rejection frequencies are small with <span class="math inline">\(r = 1\)</span> being the
worst case with around 5% rejections. For the other cases the rejection
frequencies are all below 1%, thus rejection is rare.</p>
<p>A visual comparison of <span class="math inline">\(q\)</span> to the (unnormalized) Gaussian density also
shows that the two (unnormalized) densities are very close except
in the tails where there is very little probability mass.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:densComparison"></span>
<img src="CSwR_files/figure-html/densComparison-1.png" alt="Comparisons of the Gaussian proposal (red) and the target density (blue) used for eventually simulating gamma distributed variables via a transformation." width="100%"><p class="caption">
Figure 4.5: Comparisons of the Gaussian proposal (red) and the target density (blue) used for eventually simulating gamma distributed variables via a transformation.
</p>
</div>
</div>
</div>
<div id="adaptive" class="section level2" number="4.4">
<h2>
<span class="header-section-number">4.4</span> Adaptive envelopes<a class="anchor" aria-label="anchor" href="#adaptive"><i class="fas fa-link"></i></a>
</h2>
<p>A good envelope should be tight, meaning that <span class="math inline">\(\alpha\)</span> is close to one,
it should be fast to simulate from and have a density that is
fast to evaluate. It is not obvious how to find such an envelope
for an arbitrary target density <span class="math inline">\(f\)</span>.</p>
<p>This section develops a general scheme for the construction of envelopes
for all <a href="https://en.wikipedia.org/wiki/Logarithmically_concave_function#Log-concave_distributions">log-concave target densities</a>. This is a special class of densities,
but it is not uncommon in practice. The scheme can also be extended to work
for some densities that have combinations of log-concave and log-convex
behaviors. The same idea used for constructing
envelopes can be used to bound <span class="math inline">\(f\)</span> from below. The accept-reject step
can then avoid many evaluations of <span class="math inline">\(f\)</span>, which is beneficial if <span class="math inline">\(f\)</span> is
computationally expensive to evaluate.</p>
<p>The key idea of the scheme is to bound the log-density by piecewise
affine functions. This is particularly easy to do if the density
is log-concave. The scheme leads to analytically manageable
formulas for the envelope, its corresponding distribution function and its
inverse, and as a result it is fast to simulate proposals and
compute the envelope as needed in the accept-reject step.</p>
<p>The scheme requires the choice of a finite number of points to determine
the affine bounds. For any given choice of points the scheme adapts the
envelope to the target density automatically. It is possible to implement
a <em>fully</em> adaptive scheme that doesn’t even require the choice of points
but initializes and updates the points dynamically as more and more rejection
samples are computed. In this section the focus is on the scheme with
a given and fixed number of points.</p>
<p>For a continuously differentiable, strictly positive and
log-concave target on an open interval <span class="math inline">\(I \subseteq \mathbb{R}\)</span>
it holds that
<span class="math display">\[\log(f(x)) \leq \frac{f'(x_0)}{f(x_0)}(x - x_0) + \log(f(x_0))\]</span>
for any <span class="math inline">\(x, x_0 \in I\)</span>.</p>
<p>Let <span class="math inline">\(x_1 &lt; x_2 &lt; \ldots &lt; x_{m} \in I\)</span> and let <span class="math inline">\(I_1, \ldots, I_m \subseteq I\)</span> be
intervals that form a partition of <span class="math inline">\(I\)</span> such that <span class="math inline">\(x_i \in I_i\)</span>. Defining
<span class="math display">\[a_i = (\log(f(x_i)))' = \frac{f'(x_i)}{f(x_i)} \quad \text{and} \quad b_i = \log(f(x_i)) -  \alpha_i x_i\]</span>
we find the upper bound
<span class="math display">\[\log(f(x)) \leq V(x) = \sum_{i=1}^m  (a_i x + b_i) 1_{I_i}(x),\]</span>
or
<span class="math display">\[f(x) \leq e^{V(x)}.\]</span>
Note that by the log-concavity of <span class="math inline">\(f\)</span>, <span class="math inline">\(a_1 \geq a_2 \geq \ldots \geq a_m\)</span>.
The upper bound is integrable over <span class="math inline">\(I\)</span> if either <span class="math inline">\(a_1 &gt; 0\)</span> and <span class="math inline">\(a_m &lt; 0\)</span>,
or <span class="math inline">\(a_m &lt; 0\)</span> and <span class="math inline">\(I\)</span> is bounded to the left, or <span class="math inline">\(a_1 &gt; 0\)</span> and <span class="math inline">\(I\)</span> is bounded
to the right. In any of these cases we define
<span class="math display">\[c = \int_I e^{V(x)} \mathrm{d} x &lt; \infty\]</span>
and <span class="math inline">\(g(x) = c^{-1} \exp(V(x))\)</span>, and we find that with <span class="math inline">\(\alpha = c^{-1}\)</span>
then <span class="math inline">\(\alpha f \leq g\)</span> and <span class="math inline">\(g\)</span> is an envelope of <span class="math inline">\(f\)</span>. Note that it is
actually not necessary to compute <span class="math inline">\(c\)</span> (or <span class="math inline">\(\alpha\)</span>) to implement the
rejection step in the rejection sampler, but that <span class="math inline">\(c\)</span> is needed for
simulating from <span class="math inline">\(g\)</span> as described below. We will assume in the following
that <span class="math inline">\(c &lt; \infty\)</span>.</p>
<p>The intervals <span class="math inline">\(I_i\)</span> have not been specified, and we could, in fact, implement
rejection sampling with any choice of intervals fulfilling the conditions
above. But in the interest of maximizing
<span class="math inline">\(\alpha\)</span> (minimizing <span class="math inline">\(c\)</span>) and thus minimizing the rejection frequency, we
should choose <span class="math inline">\(I_i\)</span> so that <span class="math inline">\(a_i x + b_i\)</span> is minimal over <span class="math inline">\(I_i\)</span> among all the affine
upper bounds. This will result in the tightest envelope. This means
that for <span class="math inline">\(i = 1, \ldots, m - 1\)</span>, <span class="math inline">\(I_i = (z_{i-1}, z_i]\)</span> with <span class="math inline">\(z_i\)</span>
the point where <span class="math inline">\(a_i x + b_i\)</span> and <span class="math inline">\(a_{i+1} x + b_{i+1}\)</span> intersect. We find
that the solution of
<span class="math display">\[a_i x + b_i = a_{i+1} x + b_{i+1}\]</span>
is
<span class="math display">\[z_i = \frac{b_{i+1} - b_i}{a_i - a_{i+1}}\]</span>
provided that <span class="math inline">\(a_{i+1} &gt; a_i\)</span>. The two extremes, <span class="math inline">\(z_0\)</span> and <span class="math inline">\(z_m\)</span>, are chosen
as the endpoints of <span class="math inline">\(I\)</span> and may be <span class="math inline">\(- \infty\)</span> and <span class="math inline">\(+ \infty\)</span>, respectively.</p>
<p>One way to simulate from such envelopes is by transformation
of uniform random variables by the inverse distribution function.
It requires a little bookkeeping, but is otherwise straightforward.
Define for <span class="math inline">\(x \in I_i\)</span>
<span class="math display">\[F_i(x) = \int_{z_{i-1}}^x e^{a_i z + b_i} \mathrm{d} z,\]</span>
and let <span class="math inline">\(R_i = F_i(z_i)\)</span>. Then <span class="math inline">\(c = \sum_{i=1}^m R_i\)</span>, and
if we define <span class="math inline">\(Q_i = \sum_{k=1}^{i} R_k\)</span> for <span class="math inline">\(i = 0, \ldots, m\)</span>
the inverse of the distribution function in <span class="math inline">\(q\)</span> is given as the solution to
the equation
<span class="math display">\[F_i(x) = cq - Q_{i-1}, \qquad Q_{i-1} &lt; cq \leq Q_{i}.\]</span>
That is, for a given <span class="math inline">\(q \in (0, 1)\)</span>, first determine which interval
<span class="math inline">\((Q_{i-1}, Q_{i}]\)</span> that <span class="math inline">\(c q\)</span> falls into, and then solve the corresponding
equation. Observe that when <span class="math inline">\(a_i \neq 0\)</span>,
<span class="math display">\[F_i(x) = \frac{1}{a_i}e^{b_i}\left(e^{a_i x} - e^{a_i z_{i-1}}\right).\]</span></p>
<div id="beta-distribution" class="section level3" number="4.4.1">
<h3>
<span class="header-section-number">4.4.1</span> Beta distribution<a class="anchor" aria-label="anchor" href="#beta-distribution"><i class="fas fa-link"></i></a>
</h3>
<p>To illustrate the envelope construction above for a simple log-concave
density we consider the Beta distribution on <span class="math inline">\((0, 1)\)</span> with shape parameters <span class="math inline">\(\geq 1\)</span>.
This distribution has density
<span class="math display">\[f(x) \propto x^{\alpha - 1}(1-x)^{\beta - 1},\]</span>
which is log-concave (when the shape parameters are greater than one).
We implement the rejection sampling algorithm for this density with the adaptive
envelope using two points.</p>
<div class="sourceCode" id="cb173"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">Betasim</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">x1</span>, <span class="va">x2</span>, <span class="va">alpha</span>, <span class="va">beta</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">lf</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">(</span><span class="va">alpha</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="va">beta</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">x</span><span class="op">)</span> 
  <span class="va">lf_deriv</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">(</span><span class="va">alpha</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">/</span><span class="va">x</span> <span class="op">-</span> <span class="op">(</span><span class="va">beta</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">x</span><span class="op">)</span>
  <span class="va">a1</span> <span class="op">&lt;-</span> <span class="fu">lf_deriv</span><span class="op">(</span><span class="va">x1</span><span class="op">)</span>
  <span class="va">a2</span> <span class="op">&lt;-</span> <span class="fu">lf_deriv</span><span class="op">(</span><span class="va">x2</span><span class="op">)</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">a1</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">||</span> <span class="va">a2</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">||</span> <span class="va">a1</span> <span class="op">-</span> <span class="va">a2</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> 
    <span class="kw"><a href="https://rdrr.io/r/base/stop.html">stop</a></span><span class="op">(</span><span class="st">"\nThe implementation requires a_1 and a_2 different 
and both different from zero. Choose different values of x_1 and x_2."</span><span class="op">)</span>
  <span class="va">b1</span> <span class="op">&lt;-</span> <span class="fu">lf</span><span class="op">(</span><span class="va">x1</span><span class="op">)</span> <span class="op">-</span> <span class="va">a1</span> <span class="op">*</span> <span class="va">x1</span>
  <span class="va">b2</span> <span class="op">&lt;-</span> <span class="fu">lf</span><span class="op">(</span><span class="va">x2</span><span class="op">)</span> <span class="op">-</span> <span class="va">a2</span> <span class="op">*</span> <span class="va">x2</span>
  <span class="va">z1</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">b2</span> <span class="op">-</span> <span class="va">b1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="va">a1</span> <span class="op">-</span> <span class="va">a2</span><span class="op">)</span>
  <span class="va">Q1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">b1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a1</span> <span class="op">*</span> <span class="va">z1</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span> <span class="va">a1</span> 
  <span class="va">c</span> <span class="op">&lt;-</span> <span class="va">Q1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">b2</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="fl">1</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="va">z1</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a2</span>

  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="va">uy</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span><span class="op">)</span>
  <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span><span class="op">)</span>
  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">reject</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span>
    <span class="kw">while</span><span class="op">(</span><span class="va">reject</span><span class="op">)</span> <span class="op">{</span>
      <span class="va">u0</span> <span class="op">&lt;-</span> <span class="va">c</span> <span class="op">*</span> <span class="fu">uy</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span>
      <span class="kw">if</span><span class="op">(</span><span class="va">u0</span> <span class="op">&lt;</span> <span class="va">Q1</span><span class="op">)</span> <span class="op">{</span>
        <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">a1</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">b1</span><span class="op">)</span> <span class="op">*</span> <span class="va">u0</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span> <span class="va">a1</span>
        <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lf</span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="va">a1</span> <span class="op">*</span> <span class="va">z</span> <span class="op">-</span> <span class="va">b1</span><span class="op">)</span>
      <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>
        <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">b2</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="va">u0</span> <span class="op">-</span> <span class="va">Q1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="va">z1</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a2</span>
        <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lf</span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="va">a2</span> <span class="op">*</span> <span class="va">z</span> <span class="op">-</span> <span class="va">b2</span><span class="op">)</span>
      <span class="op">}</span>
    <span class="op">}</span>
    <span class="va">y</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">z</span>
  <span class="op">}</span>
  <span class="va">y</span>
<span class="op">}</span></code></pre></div>

<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:Beta-sim"></span>
<img src="CSwR_files/figure-html/Beta-sim-1.png" alt="Histograms of simulated variables from Beta distributions using the rejection sampler with the adaptive envelope based on log-concavity. The true density (blue) and the envelope (red) are added to the plots." width="100%"><p class="caption">
Figure 4.6: Histograms of simulated variables from Beta distributions using the rejection sampler with the adaptive envelope based on log-concavity. The true density (blue) and the envelope (red) are added to the plots.
</p>
</div>
<p>Note that as a safeguard we implemented a test on the <span class="math inline">\(a_i\)</span>-s to check that
the formulas used are actually meaningful, specifically that there are no
divisions by zero.</p>
<div class="sourceCode" id="cb174"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">Betasim</span><span class="op">(</span><span class="fl">1</span>, x1 <span class="op">=</span> <span class="fl">0.25</span>, x2 <span class="op">=</span> <span class="fl">0.75</span>, alpha <span class="op">=</span> <span class="fl">4</span>, beta <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>  </code></pre></div>
<pre><code>## Error in Betasim(1, x1 = 0.25, x2 = 0.75, alpha = 4, beta = 2): ## The
implementation requires a_1 and a_2 different ## and both different from zero. Choose
different values of x_1 and x_2.```

```r
Betasim(1, x1 = 0.2, x2 = 0.75, alpha = 4, beta = 2)   </code></pre>
<pre><code>## Error in Betasim(1, x1 = 0.2, x2 = 0.75, alpha = 4, beta = 2): ## The implementation
requires a_1 and a_2 different ## and both different from zero. Choose different values
of x_1 and x_2.```

```r
Betasim(1, x1 = 0.2, x2 = 0.8, alpha = 4, beta = 2)    </code></pre>
<pre><code>## [1] 0.761879</code></pre>
</div>
<div id="von-mises-distribution" class="section level3" number="4.4.2">
<h3>
<span class="header-section-number">4.4.2</span> von Mises distribution<a class="anchor" aria-label="anchor" href="#von-mises-distribution"><i class="fas fa-link"></i></a>
</h3>
<p>The <a href="univariate-random-variables.html#vMsim">von Mises rejection sampler</a> in Section <a href="univariate-random-variables.html#vMsim">4.3.1</a> used the
uniform distribution as proposal distribution. As it turns out, the uniform
density is not a particularly tight envelope. We illustrate this by
studying the proportion of rejections for our previous implementation.</p>
<div class="sourceCode" id="cb178"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim</span><span class="op">(</span><span class="fl">10000</span>, <span class="fl">0.1</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim</span><span class="op">(</span><span class="fl">10000</span>, <span class="fl">0.5</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim</span><span class="op">(</span><span class="fl">10000</span>, <span class="fl">2</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim</span><span class="op">(</span><span class="fl">10000</span>, <span class="fl">5</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<pre><code>## kappa = 0.1 : 0.09156977 
## kappa = 0.5 : 0.3561679 
## kappa = 2 : 0.6932986 
## kappa = 5 : 0.816507</code></pre>
<p>The rejection frequency is high and increases with <span class="math inline">\(\kappa\)</span>. For <span class="math inline">\(\kappa = 5\)</span>
more than 80% of the proposals are rejected, and simulating <span class="math inline">\(n = 10,000\)</span>
von Mises distributed variables thus requires the simulation of around <span class="math inline">\(50,000\)</span>
variables from the proposal.</p>
<p>The von Mises density is, unfortunately, not log-concave on <span class="math inline">\((-\pi, \pi)\)</span>,
but it is on <span class="math inline">\((-\pi/2, \pi/2)\)</span>. It is, furthermore, log-convex on <span class="math inline">\((-\pi, -\pi/2)\)</span>
as well as <span class="math inline">\((\pi/2, \pi)\)</span>, which implies that on these two intervals the
log-density is below the corresponding chords. These chords can be
pieced together with tangents to give an envelope.</p>
<div class="sourceCode" id="cb180"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">vMsim_adapt</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">x1</span>, <span class="va">x2</span>, <span class="va">kappa</span>, <span class="va">trace</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">lf</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">kappa</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> 
  <span class="va">lf_deriv</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">-</span> <span class="va">kappa</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>
  <span class="va">a1</span> <span class="op">&lt;-</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">kappa</span> <span class="op">/</span> <span class="va">pi</span>
  <span class="va">a2</span> <span class="op">&lt;-</span> <span class="fu">lf_deriv</span><span class="op">(</span><span class="va">x1</span><span class="op">)</span>
  <span class="va">a3</span> <span class="op">&lt;-</span> <span class="fu">lf_deriv</span><span class="op">(</span><span class="va">x2</span><span class="op">)</span>
  <span class="va">a4</span> <span class="op">&lt;-</span> <span class="op">-</span> <span class="va">a1</span>
  
  <span class="va">b1</span> <span class="op">&lt;-</span> <span class="va">kappa</span>
  <span class="va">b2</span> <span class="op">&lt;-</span> <span class="fu">lf</span><span class="op">(</span><span class="va">x1</span><span class="op">)</span> <span class="op">-</span> <span class="va">a2</span> <span class="op">*</span> <span class="va">x1</span>
  <span class="va">b3</span> <span class="op">&lt;-</span> <span class="fu">lf</span><span class="op">(</span><span class="va">x2</span><span class="op">)</span> <span class="op">-</span> <span class="va">a3</span> <span class="op">*</span> <span class="va">x2</span>
  <span class="va">b4</span> <span class="op">&lt;-</span> <span class="va">kappa</span>
  
  <span class="va">z0</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="va">pi</span>
  <span class="va">z1</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="va">pi</span><span class="op">/</span><span class="fl">2</span>
  <span class="va">z2</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">b3</span> <span class="op">-</span> <span class="va">b2</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="va">a2</span> <span class="op">-</span> <span class="va">a3</span><span class="op">)</span>
  <span class="va">z3</span> <span class="op">&lt;-</span> <span class="va">pi</span><span class="op">/</span><span class="fl">2</span>
  <span class="va">z4</span> <span class="op">&lt;-</span> <span class="va">pi</span>
  
  <span class="va">Q1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">b1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a1</span> <span class="op">*</span> <span class="va">z1</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a1</span> <span class="op">*</span> <span class="va">z0</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a1</span> 
  <span class="va">Q2</span> <span class="op">&lt;-</span> <span class="va">Q1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">b2</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="va">z2</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="va">z1</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a2</span>
  <span class="va">Q3</span> <span class="op">&lt;-</span> <span class="va">Q2</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">b3</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a3</span> <span class="op">*</span> <span class="va">z3</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a3</span> <span class="op">*</span> <span class="va">z2</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a3</span>
  <span class="va">c</span> <span class="op">&lt;-</span> <span class="va">Q3</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">b4</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a4</span> <span class="op">*</span> <span class="va">z4</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a4</span> <span class="op">*</span> <span class="va">z3</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a4</span>
  
  <span class="va">count</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="va">uy</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span><span class="op">)</span>
  <span class="va">u</span> <span class="op">&lt;-</span> <span class="fu">rng_stream</span><span class="op">(</span><span class="va">n</span>, <span class="va">runif</span><span class="op">)</span>
  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">reject</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span>
    <span class="kw">while</span><span class="op">(</span><span class="va">reject</span><span class="op">)</span> <span class="op">{</span>
      <span class="va">count</span> <span class="op">&lt;-</span> <span class="va">count</span> <span class="op">+</span> <span class="fl">1</span>
      <span class="va">u0</span> <span class="op">&lt;-</span> <span class="va">c</span> <span class="op">*</span> <span class="fu">uy</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span>
      <span class="kw">if</span><span class="op">(</span><span class="va">u0</span> <span class="op">&lt;</span> <span class="va">Q1</span><span class="op">)</span> <span class="op">{</span>
        <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">a1</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">b1</span><span class="op">)</span> <span class="op">*</span> <span class="va">u0</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a1</span> <span class="op">*</span> <span class="va">z0</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a1</span>
        <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lf</span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="va">a1</span> <span class="op">*</span> <span class="va">z</span> <span class="op">-</span> <span class="va">b1</span><span class="op">)</span>
      <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="va">u0</span> <span class="op">&lt;</span> <span class="va">Q2</span><span class="op">)</span> <span class="op">{</span>
        <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">b2</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="va">u0</span> <span class="op">-</span> <span class="va">Q1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a2</span> <span class="op">*</span> <span class="va">z1</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a2</span>
        <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lf</span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="va">a2</span> <span class="op">*</span> <span class="va">z</span> <span class="op">-</span> <span class="va">b2</span><span class="op">)</span>
      <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="va">u0</span> <span class="op">&lt;</span> <span class="va">Q3</span><span class="op">)</span> <span class="op">{</span>
        <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">a3</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">b3</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="va">u0</span> <span class="op">-</span> <span class="va">Q2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a3</span> <span class="op">*</span> <span class="va">z2</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a3</span>
        <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lf</span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="va">a3</span> <span class="op">*</span> <span class="va">z</span> <span class="op">-</span> <span class="va">b3</span><span class="op">)</span>
      <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>
        <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">a4</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">b4</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="va">u0</span> <span class="op">-</span> <span class="va">Q3</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">a4</span> <span class="op">*</span> <span class="va">z3</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="va">a4</span>
        <span class="va">reject</span> <span class="op">&lt;-</span> <span class="fu">u</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="va">i</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lf</span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">-</span> <span class="va">a4</span> <span class="op">*</span> <span class="va">z</span> <span class="op">-</span> <span class="va">b4</span><span class="op">)</span>
      <span class="op">}</span>
    <span class="op">}</span>
    <span class="va">y</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">z</span>
  <span class="op">}</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">trace</span><span class="op">)</span>
    <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"kappa ="</span>, <span class="va">kappa</span>, <span class="st">", x1 ="</span>, <span class="va">x1</span>, 
        <span class="st">", x2 ="</span>, <span class="va">x2</span>, <span class="st">":"</span>, <span class="op">(</span><span class="va">count</span> <span class="op">-</span> <span class="va">n</span><span class="op">)</span> <span class="op">/</span> <span class="va">count</span>, <span class="st">"\n"</span><span class="op">)</span>  
  <span class="va">y</span>
<span class="op">}</span></code></pre></div>

<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vM-adaptive-test"></span>
<img src="CSwR_files/figure-html/vM-adaptive-test-1.png" alt="Histograms of simulated variables from von Mises distributions using the rejection sampler with the adaptive envelope based on a combination of log-concavity and log-convexity. The true density (blue) and the envelope (red) are added to the plots." width="100%"><p class="caption">
Figure 4.7: Histograms of simulated variables from von Mises distributions using the rejection sampler with the adaptive envelope based on a combination of log-concavity and log-convexity. The true density (blue) and the envelope (red) are added to the plots.
</p>
</div>
<div class="sourceCode" id="cb181"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100000</span>, <span class="op">-</span><span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">5</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100000</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">2</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100000</span>, <span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">5</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100000</span>, <span class="op">-</span><span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">2</span>, trace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<pre><code>## kappa = 5 , x1 = -0.4 , x2 = 0.4 : 0.1996414 
## kappa = 2 , x1 = -1 , x2 = 1 : 0.2412459 
## kappa = 5 , x1 = -0.1 , x2 = 0.1 : 0.4844059 
## kappa = 2 , x1 = -0.4 , x2 = 0.4 : 0.1557619</code></pre>
<p>We see that compared to using the uniform density as envelope, these adaptive
envelopes are generally tighter and leads to fewer rejections. Even tighter
envelopes are possible by using more than four intervals, but it is, of course,
always a good question how the added complexity and bookkeeping induced by
using more advanced and adaptive envelopes affect run time. It is even a good question
if our current adaptive implementation will outperform our first, and
much simpler, implementation that used the uniform envelope.</p>
<div class="sourceCode" id="cb183"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html">microbenchmark</a></span><span class="op">(</span><span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>,
               <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100</span>, <span class="op">-</span><span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">5</span><span class="op">)</span>,
               <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="fl">5</span><span class="op">)</span>,
               <span class="fu">vMsim_adapt</span><span class="op">(</span><span class="fl">100</span>, <span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">5</span><span class="op">)</span>,
               <span class="fu">vMsim</span><span class="op">(</span><span class="fl">100</span>, <span class="fl">5</span><span class="op">)</span>,
               <span class="fu">vMsim_vec</span><span class="op">(</span><span class="fl">100</span>, <span class="fl">5</span><span class="op">)</span>
               <span class="op">)</span></code></pre></div>
<pre><code>## Unit: microseconds
##                            expr min  lq mean median   uq    max neval
##      vMsim_adapt(100, -1, 1, 5) 772 915 1208   1080 1406   3439   100
##  vMsim_adapt(100, -0.4, 0.4, 5) 410 463  738    526  581  18252   100
##  vMsim_adapt(100, -0.2, 0.2, 5) 466 564  704    607  811   1419   100
##  vMsim_adapt(100, -0.1, 0.1, 5) 573 673 3613    761  959 269242   100
##                   vMsim(100, 5) 767 998 1292   1100 1472   3171   100
##               vMsim_vec(100, 5)  77 116  202    140  179   1793   100</code></pre>
<p>The results from the benchmark show that the adaptive implementation has
run time comparable to using the uniform proposal.
With <span class="math inline">\(x_1 = -0.4\)</span> and <span class="math inline">\(x_2 = 0.4\)</span> and <span class="math inline">\(\kappa = 5\)</span>
we found above that the rejection frequency was about 20% with
the adaptive envelope, while it was about 80% when using the uniform
envelope. A naive computation would thus suggest a speedup of a
factor 4, but using the adaptive envelope there is actually only
a speedup of a factor 2. And the vectorized solution is still
considerably faster. A completely vectorized solution using
the adaptive envelope is possible, but it is not entirely
straightforward how to implement the more complicated envelope
efficiently, and it may be a better option in this case to implement
it using Rcpp.</p>
<p>Even if either implementation can be improved further in terms of run time,
it is an important point when comparing algorithms that we don’t get too
focused on surrogate performance quantities. The probability of rejection
is a surrogate for actual run time, and it might be conceptually of interest
to bring this probability down. But if it is at the expense of additional
computations it might not be worth the effort in terms of real run time.</p>
</div>
</div>
<div id="univariate:ex" class="section level2" number="4.5">
<h2>
<span class="header-section-number">4.5</span> Exercises<a class="anchor" aria-label="anchor" href="#univariate:ex"><i class="fas fa-link"></i></a>
</h2>
<div id="rejection-sampling-of-gaussian-random-variables" class="section level3" number="4.5.1">
<h3>
<span class="header-section-number">4.5.1</span> Rejection sampling of Gaussian random variables<a class="anchor" aria-label="anchor" href="#rejection-sampling-of-gaussian-random-variables"><i class="fas fa-link"></i></a>
</h3>
<p>This exercise is on rejection sampling from the Gaussian distribution by
using the Laplace distribution as an envelope. Recall that the Laplace distribution has density
<span class="math display">\[g(x) = \frac{1}{2} e^{-|x|}\]</span>
for <span class="math inline">\(x \in \mathbb{R}\)</span>.</p>
<p>Note that if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent and exponentially distributed with mean one, then <span class="math inline">\(X - Y\)</span> has a Laplace
distribution. This gives a way to easily sample from the Laplace distribution.</p>

<div class="exercise">
<p><span id="exr:reject-gaussian" class="exercise"><strong>Exercise 4.1  </strong></span>Implement rejection sampling from the standard Gaussian distribution with density
<span class="math display">\[f(x) = \frac{1}{\sqrt{2\pi}} e^{- x^2 / 2}\]</span>
by simulating Laplace random variables as differences of exponentially distributed random variables.
Test the implementation by computing the variance of the Gaussian distribution
as an MC estimate and by comparing directly with the Gaussian distribution using
histograms and QQ-plots.</p>
</div>

<div class="exercise">
<p><span id="exr:unnamed-chunk-4" class="exercise"><strong>Exercise 4.2  </strong></span>Implement simulation from the Laplace distribution by transforming a uniform random variable by
the inverse distribution function. Use this method together with the rejection
sampler you implemented in Exercise <a href="univariate-random-variables.html#exr:reject-gaussian">4.1</a></p>
</div>
<p><strong>Note:</strong> The Laplace distribution can be seen as a simple version of the
adaptive envelopes suggested in Section <a href="univariate-random-variables.html#adaptive">4.4</a>.</p>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="bivariate.html"><span class="header-section-number">3</span> Bivariate smoothing</a></div>
<div class="next"><a href="mci.html"><span class="header-section-number">5</span> Monte Carlo integration</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#univariate-random-variables"><span class="header-section-number">4</span> Univariate random variables</a></li>
<li>
<a class="nav-link" href="#pseudorandom-number-generators"><span class="header-section-number">4.1</span> Pseudorandom number generators</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#implementing-a-pseudorandom-number-generator"><span class="header-section-number">4.1.1</span> Implementing a pseudorandom number generator</a></li>
<li><a class="nav-link" href="#rng-packages"><span class="header-section-number">4.1.2</span> Pseudorandom number packages</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#transformation-techniques"><span class="header-section-number">4.2</span> Transformation techniques</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#sampling-from-a-t-distribution"><span class="header-section-number">4.2.1</span> Sampling from a \(t\)-distribution</a></li></ul>
</li>
<li>
<a class="nav-link" href="#reject-samp"><span class="header-section-number">4.3</span> Rejection sampling</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#vMsim"><span class="header-section-number">4.3.1</span> von Mises distribution</a></li>
<li><a class="nav-link" href="#gamma-distribution"><span class="header-section-number">4.3.2</span> Gamma distribution</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#adaptive"><span class="header-section-number">4.4</span> Adaptive envelopes</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#beta-distribution"><span class="header-section-number">4.4.1</span> Beta distribution</a></li>
<li><a class="nav-link" href="#von-mises-distribution"><span class="header-section-number">4.4.2</span> von Mises distribution</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#univariate:ex"><span class="header-section-number">4.5</span> Exercises</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#rejection-sampling-of-gaussian-random-variables"><span class="header-section-number">4.5.1</span> Rejection sampling of Gaussian random variables</a></li></ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/nielsrhansen/CSwR/blob/master/12-Univariate.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/nielsrhansen/CSwR/edit/master/12-Univariate.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Computational Statistics with R</strong>" was written by Niels Richard Hansen. It was last built on 2022-05-08, Git version: c532a37.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
